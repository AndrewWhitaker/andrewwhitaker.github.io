<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: QueryOver Series | Andrew Whitaker]]></title>
  <link href="http://www.andrewwhitaker.com/blog/categories/queryover-series/atom.xml" rel="self"/>
  <link href="http://www.andrewwhitaker.com/"/>
  <updated>2016-07-30T17:38:45-05:00</updated>
  <id>http://www.andrewwhitaker.com/</id>
  <author>
    <name><![CDATA[Andrew Whitaker]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[QueryOver Series - Part 10: Combining Criteria and QueryOver]]></title>
    <link href="http://www.andrewwhitaker.com/blog/2015/05/31/queryover-series-part-10-combining-criteria-and-queryover/"/>
    <updated>2015-05-31T19:43:08-05:00</updated>
    <id>http://www.andrewwhitaker.com/blog/2015/05/31/queryover-series-part-10-combining-criteria-and-queryover</id>
    <content type="html"><![CDATA[<p>As I mentioned in the first post in this series, QueryOver is built on top of NHibernate&rsquo;s Criteria API. In this post, I&rsquo;ll explore how to mix QueryOver and Criteria functionality to enable powerful query building techniques.</p>

<!-- more -->


<p>*This article is part of an ongoing series on NHibernate Queryover. Click [here](/queryover-series) to see the table of contents.*</p>

<h2>Building truly dynamic queries</h2>

<p>If you&rsquo;ve read the article in this series about dynamically building queries, then you already know that with QueryOver you can conditionally add <code>WHERE</code> clauses and even <code>JOIN</code>s to a query without messy string manipulation. This functionality is very powerful and might be all you ever need. However, you can write even <em>more</em> flexible queries by combining QueryOver with Criteria.</p>

<p>For example, lets say you&rsquo;re building a product searching application and you want to let users search on any attribute of the product they&rsquo;d like. You could start with a QueryOver query that looks like this:</p>

<p>```csharp
public static IList<Product> QueryProducts(ISession session, string column, string value)
{</p>

<pre><code>Expression&lt;Func&lt;Product, object&gt;&gt; propertyExpression = null;

if (column == "Name")
{
    propertyExpression = pr =&gt; pr.Name;
}
else if (column == "Color")
{
    propertyExpression = pr =&gt; pr.Color;
}

return session.QueryOver&lt;Product&gt;()
    .Where(Restrictions.Eq(Projections.Property&lt;Product&gt;(propertyExpression), value))
    .List&lt;Product&gt;();
</code></pre>

<p>}
```</p>

<p>You&rsquo;ve probably noticed the problem. Since QueryOver works with <code>Expression</code>s, we have to figure out what the user typed, then build the appropriate expression. This is boring and ugly. Lets see if we can use Criteria&rsquo;s functionality to simplify things.</p>

<h3>Simplifying things using Criteria</h3>

<p>First it might be helpful to step back and remember what a Criteria query looks like. If we were writing the <code>QueryProducts</code> method with a Criteria query, we could write it like this:</p>

<p>```csharp
public static IList<Product> QueryProducts(ISession session, string column, string value)
{</p>

<pre><code>return session.CreateCriteria&lt;Product&gt;()
    .Add(Restrictions.Eq(column, value))
    .List&lt;Product&gt;();
</code></pre>

<p>}
```</p>

<p>Here, we&rsquo;re passing the user&rsquo;s input directly to <code>Restrictions.Eq</code>.</p>

<p>Before we go any further, I should mention that this does <em>not</em> open you to SQL injection. If you attempt to supply a value to <code>column</code> that is not a mapped column for the <code>Product</code> class, NHibernate throws an exception.</p>

<p>That said, throwing an exception isn&rsquo;t the most user-friendly thing in the world. We&rsquo;ll look at some ways to help with that later on.</p>

<h3>Combining QueryOver and Criteria</h3>

<p>A combination of the two versions of <code>QueryProducts</code> gives us this:</p>

<p>```csharp
public static IList<Product> QueryProducts(ISession session, string column, string value)
{</p>

<pre><code>return session.QueryOver&lt;Product&gt;()
    .Where(Restrictions.Eq(column, value))
    .List&lt;Product&gt;();
</code></pre>

<p>}
```</p>

<p>That was pretty easy! But before you go committing that and introducing bugs you&rsquo;ll discover later on, there are two major pitfalls I need to address. Both problems are solved the same way, so I&rsquo;ll introduce the problems first.</p>

<h4>Joining</h4>

<p>So imagine <code>QueryProducts</code> has been running smoothly for a few months. Now, however, you&rsquo;d like to add to the query. You need to <code>JOIN</code> to the <code>TransactionHistory</code> table and only retrieve products that have been modified in the last 7 days (you don&rsquo;t want customers seeing old stock). No problem&mdash; you make the following modification:</p>

<p>```csharp
public static IList<Product> QueryProducts(ISession session, string column, string value)
{</p>

<pre><code>return session.QueryOver&lt;Product&gt;()
    .JoinQueryOver(pr =&gt; pr.TransactionHistory)
        .Where(tx =&gt; tx.ModifiedDate &gt; DateTime.Now.AddDays(-7))
    .Where(Restrictions.Eq(column, value))
    .List&lt;Product&gt;();
</code></pre>

<p>}
```</p>

<p>That was easy right? Well, if you were to run this, NHibernate would throw an exception:</p>

<p>```
  Message=could not resolve property: Color of: AdventureWorks.Entities.Production.TransactionHistory
  Source=NHibernate
  StackTrace:</p>

<pre><code>   at NHibernate.Persister.Entity.AbstractPropertyMapping.ToType(String propertyName)
   at NHibernate.Persister.Entity.AbstractEntityPersister.GetSubclassPropertyTableNumber(String propertyPath)
   at NHibernate.Persister.Entity.BasicEntityPropertyMapping.ToColumns(String alias, String propertyName)
   at NHibernate.Persister.Entity.AbstractEntityPersister.ToColumns(String alias, String propertyName)
   at NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetColumns(ICriteria subcriteria, String propertyName)
   at NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetColumnsUsingProjection(ICriteria subcriteria, String propertyName)
   at NHibernate.Criterion.CriterionUtil.GetColumnNamesUsingPropertyName(ICriteriaQuery criteriaQuery, ICriteria criteria, String propertyName, Object value, ICriterion critertion)
   at NHibernate.Criterion.CriterionUtil.GetColumnNamesForSimpleExpression(String propertyName, IProjection projection, ICriteriaQuery criteriaQuery, ICriteria criteria, IDictionary`2 enabledFilters, ICriterion criterion, Object value)
   /* etc */
</code></pre>

<p>```</p>

<p>What happened here? To understand we need to go back to the <a href="../blog/2014/03/16/queryover-series-part-2-basics/">Basics and Joining</a> article. When you use <code>JoinQueryOver</code>, you&rsquo;re changing the context of any <code>.Where</code> calls that follow to the table you&rsquo;ve joined on. After calling <code>JoinQueryOver</code>, NHibernate thinks that we&rsquo;re trying to access the <code>Color</code> property of <code>TransactionHistory</code>.</p>

<p>You could just move the <code>.Where</code> call <em>before</em> the <code>JoinQueryOver</code> call, but this can be hard to keep track of with a big query. There&rsquo;s a more robust solution.</p>

<h4>Aliases</h4>

<p>Our simple <code>Product</code> query doesn&rsquo;t have this problem yet, but consider another query, this one starting at <code>TransactionHistory</code> and joining to <code>Product</code>:</p>

<p>```csharp
Product productAlias = null;</p>

<p>session.QueryOver<TransactionHistory>()</p>

<pre><code>.JoinAlias(tx =&gt; tx.Product, () =&gt; productAlias)
.Where(Restrictions.Eq(column, value))
.List();
</code></pre>

<p>```</p>

<p>This query throws the same exception that the above query throws. You need some way to combine the supplied column name with the alias that you&rsquo;re supplying NHibernate. How can we solve these problems?</p>

<h3>Incorporating aliases</h3>

<p>The key to solving the problems is using aliases along with our dynamic column name. Again, this is easier using Criteria directly:</p>

<p>```csharp
session.CreateCriteria<TransactionHistory>()</p>

<pre><code>.CreateAlias("Product", "productAlias")
.Add(Restrictions.Eq("productAlias." + column, value))
.List&lt;TransactionHistory&gt;();
</code></pre>

<p>```</p>

<p>Here, when we join to the <code>Product</code> table, we&rsquo;re assigning an alias (<code>"productAlias"</code>), that we&rsquo;re using later to create a property access expression (in the form of a <code>string</code>) that NHibernate understands.</p>

<p>We can use the same strategy with QueryOver, but it takes a few steps.</p>

<h4>1. Determine the name of the alias we&rsquo;re using</h4>

<p>Under the hood, NHibernate is going to turn the <code>Expression</code> we supply to <code>JoinAlias</code> into a <code>string</code> that gets used the same way that the alias name supplied to <code>CreateAlias</code> is used. If we can determine the name of the alias, we can prepend that to the property we&rsquo;re trying to access.</p>

<p>To do this, we can use the <code>NHibernate.Impl.ExpressionProcessor</code> class:</p>

<p>```csharp
Product productAlias = null;</p>

<p>Expression&lt;Func<Product>> productAliasExpression = () => productAlias;</p>

<p>string productAliasName =</p>

<pre><code>ExpressionProcessor.FindMemberExpression(productAliasExpression.Body);
</code></pre>

<p>```</p>

<p>Now, we&rsquo;ll have the name of the alias in the form of a <code>string</code>. Note that we could just use the string <code>"productAlias"</code> here, but that doesn&rsquo;t stand up well to refactoring.</p>

<h4>2. Combine the alias with the supplied property</h4>

<p>The next step is easy: just combine the alias name with the property we&rsquo;re trying to query on:</p>

<p>```csharp
Product productAlias = null;</p>

<p>Expression&lt;Func<Product>> productAliasExpr = () => productAlias;</p>

<p>string productAliasName = ExpressionProcessor.FindMemberExpression(productAliasExpr.Body);</p>

<p>session.QueryOver<TransactionHistory>()</p>

<pre><code>.JoinAlias(tx =&gt; tx.Product, productAliasExpr)
.Where(Restrictions.Eq(string.Format("{0}.{1}", productAliasName, column), value))
.List();
</code></pre>

<p>```</p>

<p>This is a little messy, so lets refactor the property access building code into a helper function:</p>

<p>```csharp
public static string BuildPropertyAccess<T>(Expression&lt;Func<T>> alias, string propertyName)
{</p>

<pre><code>string aliasName = ExpressionProcessor.FindMemberExpression(alias.Body);

return string.Format("{0}.{1}", aliasName, propertyName);
</code></pre>

<p>}
```</p>

<p>Now our query looks like this:</p>

<p>```csharp
Product productAlias = null;</p>

<p>Expression&lt;Func<Product>> productAliasExpr = () => productAlias;</p>

<p>session.QueryOver<TransactionHistory>()</p>

<pre><code>.JoinAlias(tx =&gt; tx.Product, productAliasExpr)
.Where(Restrictions.Eq(BuildPropertyAccess(productAliasExpr, column), value))
.List();
</code></pre>

<p>```</p>

<p>This also fixes the problem with the query performing the <code>JOIN</code> from earlier:</p>

<p>```csharp
public static IList<Product> QueryProducts(ISession session, string column, string value)
{</p>

<pre><code>Product productAlias = null;

Expression&lt;Func&lt;Product&gt;&gt; productAliasExpr = () =&gt; productAlias;

return session.QueryOver&lt;Product&gt;(productAliasExpr)
    .JoinQueryOver(pr =&gt; pr.TransactionHistory)
        .Where(tx =&gt; tx.ModifiedDate &gt; DateTime.Now.AddDays(-7))
    .Where(Restrictions.Eq(BuildPropertyAccess(productAliasExpr, column), value))
    .List&lt;Product&gt;();
</code></pre>

<p>}
```</p>

<p>The call to <code>session.QueryOver</code> also assigns an alias that we can use later to build the <code>Restriction</code> correctly.</p>

<h3>Validating supplied property names</h3>

<p>The last piece of this is to nicely be able to let the user know that they&rsquo;ve supplied an invalid property name.</p>

<p>Using <a href="http://stackoverflow.com/a/856791/497356">this answer</a> as a guide, we can use the following method to determine if a given property name is mapped and queryable:</p>

<p>```csharp
public static bool IsMappedProperty<T>(string property, ISessionFactory sessionFactory)
{</p>

<pre><code>IClassMetadata metadata = sessionFactory.GetClassMetadata(typeof(T));

return metadata.PropertyNames.Contains(property);
</code></pre>

<p>}
```</p>

<p>Now we have a nice way to validate the user&rsquo;s input before attempting to query using it.</p>

<p>With all that in mind, here&rsquo;s a complete(ish) demonstration:</p>

<p>```csharp
public static void Query(ISession session)
{</p>

<pre><code>Console.Write("Please enter a column to query on: ");
string col = Console.ReadLine();

Console.Write("Please enter a value to query for: ");
string value = Console.ReadLine();

if (IsMappedProperty&lt;Product&gt;(col, session.SessionFactory))
{
    QueryProducts(session, col, value);
}
else
{
    Console.WriteLine("Invalid property name.");
}
</code></pre>

<p>}</p>

<p>public static bool IsMappedProperty<T>(string property, ISessionFactory sessionFactory)
{</p>

<pre><code>IClassMetadata metadata = sessionFactory.GetClassMetadata(typeof(T));

return metadata.PropertyNames.Contains(property);
</code></pre>

<p>}</p>

<p>public static IList<Product> QueryProducts(ISession session, string column, string value)
{</p>

<pre><code>Product productAlias = null;

Expression&lt;Func&lt;Product&gt;&gt; productAliasExpr = () =&gt; productAlias;

return session.QueryOver&lt;Product&gt;(productAliasExpr)
    .JoinQueryOver(pr =&gt; pr.TransactionHistory)
        .Where(tx =&gt; tx.ModifiedDate &gt; DateTime.Now.AddDays(-7))
    .Where(Restrictions.Eq(BuildPropertyAccess(productAliasExpr, column), value))
    .List&lt;Product&gt;();
</code></pre>

<p>}</p>

<p>public static string BuildPropertyAccess<T>(Expression&lt;Func<T>> alias, string propertyName)
{</p>

<pre><code>string aliasName = ExpressionProcessor.FindMemberExpression(alias.Body);

return string.Format("{0}.{1}", aliasName, propertyName);
</code></pre>

<p>}
```</p>

<p>And that&rsquo;s it! It took awhile to get here, but hopefully you see some potential in this technique. Keep in mind that you&rsquo;re not limited to <code>Restrictions.Eq</code>. You can use this strategy with anything that works with an <code>IProjection</code>, as long as you build the projection properly. This includes building dynamic <code>SELECT</code> clauses, which would be an interesting application.</p>

<h2>Summary</h2>

<ul>
<li>With a normal QueryOver query, it&rsquo;s hard to dynamically choose property names because QueryOver works with strongly-typed <code>Expression</code>s.</li>
<li>We can mix QueryOver with Criteria to dynamically supply column names&hellip;</li>
<li>&hellip; but we need to assign aliases to entities involved in the queries in order to generate the correct SQL.</li>
<li>We can check for valid property names using the <code>GetClassMetadata</code> function on <code>ISessionFactory</code>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QueryOver Series - Part 9: Extending QueryOver to Use Custom Methods and Properties]]></title>
    <link href="http://www.andrewwhitaker.com/blog/2015/01/28/queryover-series-part-9-extending-queryover-using-custom-methods-and-properties/"/>
    <updated>2015-01-28T19:05:39-06:00</updated>
    <id>http://www.andrewwhitaker.com/blog/2015/01/28/queryover-series-part-9-extending-queryover-using-custom-methods-and-properties</id>
    <content type="html"><![CDATA[<p>A basic tenet of QueryOver queries is that you can&rsquo;t query against unmapped properties. While this is generally true, in this post I&rsquo;ll outline some strategies you can use to register properties and functions with QueryOver so that they generate meaningful SQL.</p>

<!-- more -->


<p>*This article is part of an ongoing series on NHibernate Queryover. Click [here](/queryover-series) to see the table of contents.*</p>

<h2>Basics</h2>

<p>Just as a refresher, consider the following class:</p>

<p>```csharp
public class Rectangle
{</p>

<pre><code>public Rectangle(double width, double height)
{
    this.Width = width;
    this.Height = height;
}

protected Rectangle()
{
}

public virtual int Id { get; set; }

public virtual double Width { get; protected set; }

public virtual double Height { get; protected set; }

public virtual double Area
{
    get { return this.Width * this.Height; }
}
</code></pre>

<p>}
```</p>

<p>Nothing too complicated right? This class maps to the following database table:</p>

<p>```sql
create table [Rectangle]
(</p>

<pre><code>[Id] int identity(1,1) primary key clustered,
[Width] float not null,
[Height] float not null
</code></pre>

<p>)
```</p>

<p>Notice that there&rsquo;s no <code>Area</code> column in the database. This property is computed by C# code. When you attempt to query against it using QueryOver:</p>

<p>```csharp
session.QueryOver<Rectangle>()</p>

<pre><code>.Where(r =&gt; r.Area &gt; 4.0)
.List&lt;Rectangle&gt;();
</code></pre>

<p>```</p>

<p>You&rsquo;ll get the following exception:</p>

<p>```
NHibernate.QueryException was unhandled
  HResult=-2146232832
  Message=could not resolve property: Area of: Rectangle.Rectangle
  Source=NHibernate
  StackTrace:</p>

<pre><code>   at NHibernate.Persister.Entity.AbstractPropertyMapping.ToType(String propertyName)
   at NHibernate.Persister.Entity.AbstractEntityPersister.GetSubclassPropertyTableNumber(String propertyPath)
   at NHibernate.Persister.Entity.BasicEntityPropertyMapping.ToColumns(String alias, String propertyName)
   at NHibernate.Persister.Entity.AbstractEntityPersister.ToColumns(String alias, String propertyName)
   at NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetColumns(ICriteria subcriteria, String propertyName)
   at NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetColumnsUsingProjection(ICriteria subcriteria, String propertyName)
   at NHibernate.Criterion.CriterionUtil.GetColumnNamesUsingPropertyName(ICriteriaQuery criteriaQuery, ICriteria criteria, String propertyName, Object value, ICriterion critertion)
   at NHibernate.Criterion.CriterionUtil.GetColumnNamesForSimpleExpression(String propertyName, IProjection projection, ICriteriaQuery criteriaQuery, ICriteria criteria, IDictionary`2 enabledFilters, ICriterion criterion, Object value)
   ...
</code></pre>

<p>```</p>

<p>The gist is that since <code>Area</code> is an unmapped property, NHibernate doesn&rsquo;t know what to do with it. Lets see if we can change that.</p>

<h2>Registering an Unmapped Property with QueryOver</h2>

<p>To get the gist of what we&rsquo;re going to do, it might be helpful to take a look at the <a href="https://github.com/nhibernate/nhibernate-core/blob/master/src/NHibernate/Criterion/ProjectionsExtensions.cs">ProjectionExtensions.cs</a> and <a href="https://github.com/nhibernate/nhibernate-core/blob/master/src/NHibernate/Impl/ExpressionProcessor.cs">ExpressionProcessor.cs</a> files in the NHibernate source code. There are only two things that we need to do:</p>

<ol>
<li>Write a function that can translate an <code>Expression</code> and turns it into a <code>Projection</code> that QueryOver can use.</li>
<li>Register the function from #1 with the <code>ExpressionProcessor</code> class referenced above.</li>
</ol>


<h3>Translating the <code>Area</code> property into a <code>Projection</code></h3>

<p>If you look at the <code>ExpressionProcessor</code> class, you&rsquo;ll see a bunch of <code>RegisterCustomProjection</code> calls. A few of them are used to let you use <code>DateTime</code> properties like <code>Month</code> or <code>Hour</code> directly in a QueryOver query. Since this is really close to what we want to do with the <code>Area</code> property, lets follow those methods as an example.</p>

<p>Taking a closer look at <code>RegisterCustomProjection</code>, you&rsquo;ll notice that the function takes two arguments:</p>

<ol>
<li>The property or method we want to register, and</li>
<li>A <code>Func&lt;MemberExpression, IProjection</code>. In other words, a lambda that takes a <code>MemberExpression</code> and returns an <code>IProjection</code>.</li>
</ol>


<p>Let&rsquo;s implement #2 first.</p>

<h4>Implementing the <code>ProcessArea</code> function</h4>

<p>The hardest part of this process is going to be the <code>ProcessArea</code> function that will take an expression and somehow return a projection that computes the length. Here&rsquo;s what that looks like:</p>

<p>```csharp
public static class RectangleExtensions
{</p>

<pre><code>/// &lt;summary&gt;
/// Helper function that takes an "alias" and property name and combines them into 
/// property access that can then be used in a projection.
/// &lt;/summary&gt;
/// &lt;param name="alias"&gt;The alias.&lt;/param&gt;
/// &lt;param name="property"&gt;The property.&lt;/param&gt;
/// &lt;returns&gt;A string representing full property access.&lt;/returns&gt;
private static string BuildPropertyName(string alias, string property)
{
    if (!string.IsNullOrEmpty(alias))
    {
        return string.Format("{0}.{1}", alias, property);
    }

    return property;
}

/// &lt;summary&gt;
/// Processes the "Area" property access, an unmapped property,
/// and turns it into a computation on the SQL side.
/// &lt;/summary&gt;
/// &lt;param name="expression"&gt;The expression to process.&lt;/param&gt;
/// &lt;returns&gt;The resulting projection.&lt;/returns&gt;
public static IProjection ProcessArea(System.Linq.Expressions.Expression expression)
{
    /* Expressions from which we can get "Width" and "Height" property names to 
     * build a projection */
    Expression&lt;Func&lt;Rectangle, double&gt;&gt; w = r =&gt; r.Width;
    Expression&lt;Func&lt;Rectangle, double&gt;&gt; h = r =&gt; r.Height;

    /* The name of the alias used in the query, if any */
    string aliasName = ExpressionProcessor.FindMemberExpression(expression);

    /* Retrieves the strings "Width" and "Height" from the expressions above */
    string widthName = ExpressionProcessor.FindMemberExpression(w.Body);
    string heightName = ExpressionProcessor.FindMemberExpression(h.Body);

    /* Combines the "Width" and "Height" strings with the alias name to 
     * build a projection: */
    PropertyProjection widthProjection = 
        Projections.Property(BuildPropertyName(aliasName, widthName));

    PropertyProjection hProjection =
        Projections.Property(BuildPropertyName(aliasName, heightName));

    /* Finally, return a SQL function that computes the product of */
     * Width and Height */
    ISQLFunction multiplication =
        new VarArgsSQLFunction(NHibernateUtil.Double, "(", "*", ")");

    return Projections.SqlFunction(
        multiplication, NHibernateUtil.Double, widthProjection, hProjection);
}
</code></pre>

<p>}
```</p>

<p>There&rsquo;s a lot going on there. Basically we need to get the <code>Width</code> and <code>Height</code> properties from the <code>Rectangle</code> class so that we can use them in a projection. This would be simple, but since the query could be using an alias, we need to combine the property names with the alias (which can be <code>string.Empty</code>) to create the proper property access.</p>

<p>Grabbing the property names as strings from <code>Expression</code>s prevents magic strings, which QueryOver is designed to prevent anyway.</p>

<p>Next, we need to build actual <code>Projection</code>s from the strings we&rsquo;ve made, which is easy using the overload of <code>Projection.Property</code> that takes a <code>string</code>.</p>

<p>Finally, we&rsquo;ll register our function with the <code>ExpressionProcessor</code>.</p>

<h4>Registering the <code>Area</code> property and <code>ProcessArea</code> function with the <code>ExpressionProcessor</code>.</h4>

<p>I don&rsquo;t think it matters exactly <em>when</em> you register your custom function, but it obviously has to be before you use the property or method in a query.</p>

<p>Here&rsquo;s what the code looks like:</p>

<p>```csharp
ExpressionProcessor.RegisterCustomProjection(</p>

<pre><code>() =&gt; default(Rectangle).Area,
expr =&gt; RectangleExtensions.ProcessArea(expr.Expression));
</code></pre>

<p>```</p>

<p>&hellip;And that&rsquo;s basically it. We&rsquo;re telling NHibernate to call the <code>ProcessArea</code> function when the <code>Rectangle.Area</code> property is used.</p>

<p>Now our original query is valid and should generate the correct SQL:</p>

<p>```sql
SELECT</p>

<pre><code>this_.Id as Id0_0_,
this_.Width as Width0_0_,
this_.Height as Height0_0_
</code></pre>

<p>FROM</p>

<pre><code>Rectangle this_
</code></pre>

<p>WHERE</p>

<pre><code>(
    this_.Width*this_.Height
) &gt; 4
</code></pre>

<p>```</p>

<h3>Using a user-defined function to compute <code>Area</code></h3>

<p>Now, lets take the concept a slightly different direction. Lets assume that the area function is defined in a user-defined function:</p>

<p>```sql
create function UFN_CalculateArea
(</p>

<pre><code>@Width float,
@Height float
</code></pre>

<p>)
returns float
as
begin</p>

<pre><code>declare @Area float;

select @Area = @Width * @Height;

return @Area;
</code></pre>

<p>end
```</p>

<p>Now our QueryOver code becomes:</p>

<p>```csharp
/// <summary>
/// Processes the &ldquo;Area&rdquo; property access, an unmapped property,
/// and turns it into a computation on the SQL side.
/// </summary>
/// <param name="expression">The expression to process.</param>
/// <returns>The resulting projection.</returns>
public static IProjection ProcessArea(System.Linq.Expressions.Expression expression)
{</p>

<pre><code>/* Expressions from which we can get "Width" and "Height" property names to 
 * build a projection */
Expression&lt;Func&lt;Rectangle, double&gt;&gt; w = r =&gt; r.Width;
Expression&lt;Func&lt;Rectangle, double&gt;&gt; h = r =&gt; r.Height;

/* The name of the alias used in the query, if any */
string aliasName = ExpressionProcessor.FindMemberExpression(expression);

/* Retrieves the strings "Width" and "Height" from the expressions above */
string widthName = ExpressionProcessor.FindMemberExpression(w.Body);
string heightName = ExpressionProcessor.FindMemberExpression(h.Body);

/* Combines the "Width" and "Height" strings with the alias name to 
 * build a projection: */
PropertyProjection widthProjection =
    Projections.Property(BuildPropertyName(aliasName, widthName));

PropertyProjection hProjection =
    Projections.Property(BuildPropertyName(aliasName, heightName));

/* Finally, return ISQLFunction that calls our user-defined function:  */
ISQLFunction multiplication =
    new SQLFunctionTemplate(NHibernateUtil.Double, "dbo.UFN_CalculateArea(?1, ?2)");

return Projections.SqlFunction(
    multiplication, NHibernateUtil.Double, widthProjection, hProjection);
</code></pre>

<p>}
```</p>

<p>And the generated SQL is what we expect:</p>

<p>```sql
SELECT</p>

<pre><code>this_.Id as Id0_0_,
this_.Width as Width0_0_,
this_.Height as Height0_0_
</code></pre>

<p>FROM</p>

<pre><code>Rectangle this_
</code></pre>

<p>WHERE</p>

<pre><code>dbo.UFN_CalculateArea(this_.Width, this_.Height) &gt; 4;
</code></pre>

<p>```</p>

<h2>Other Tips</h2>

<p>There are a few things worth noting here:</p>

<h3>Registered methods need not be implemented in C#</h3>


<p>We could actually decide not to provide an implementation for our <code>Area</code> property:</p>

<p>```csharp
public class Rectangle
{</p>

<pre><code>public Rectangle(double width, double height)
{
    this.Width = width;
    this.Height = height;
}

protected Rectangle()
{
}

public virtual int Id { get; set; }

public virtual double Width { get; protected set; }

public virtual double Height { get; protected set; }

public virtual double Area
{
    get
    {
        throw new NotImplementedException("Only available inside a QueryOver query"); 
    }
}
</code></pre>

<p>}
```</p>

<p>NHibernate will happily transform the <code>Area</code> property into the correct SQL as before&mdash;after all, it isn&rsquo;t actually <em>invoking</em> the property, it&rsquo;s evaluating it inside of an expression tree.</p>

<p>Another example of where this might be useful is for functionality that&rsquo;s actually only available in SQL. Let&rsquo;s pick on the <code>checksum</code> function. If we wanted to use that inside of a QueryOver query, one way to do that would be to create a <code>CheckSum</code> extension method and register it (check <a href="../blog/2014/08/15/queryover-series-part-7-using-sql-functions">Using SQL Functions</a> for how to add the <code>checksum</code> function with a custom dialect):</p>

<p>Here&rsquo;s our <code>CheckSum</code> method:</p>

<p>```csharp
public static class QueryOverExtensions
{</p>

<pre><code>public static int CheckSum(this object o)
{
    throw new NotImplementedException("Must be used inside of a QueryOver query.");
}
</code></pre>

<p>}
```</p>

<p>Here&rsquo;s the <code>ProcessCheckSum</code> method that processes the <code>CheckSum</code> method call into an <code>IProjection</code>:</p>

<p>```csharp
public static class Extensions
{</p>

<pre><code>public static IProjection ProcessCheckSum(MethodCallExpression methodCallExpression)
{
    IProjection property =
        ExpressionProcessor.FindMemberProjection(
            methodCallExpression.Arguments[0]).AsProjection();

    return Projections.SqlFunction("checksum", NHibernateUtil.Int32, property);
}
</code></pre>

<p>}
```</p>

<p>Finally, here&rsquo;s registering it with the <code>ExpressionProcessor</code>:</p>

<p>```csharp
ExpressionProcessor.RegisterCustomProjection(</p>

<pre><code>() =&gt; default(object).CheckSum(), Extensions.ProcessCheckSum);
</code></pre>

<p>```</p>

<p>Here&rsquo;s an example of getting a <code>checksum</code> of <code>Rectangle.Height</code>:</p>

<p>```csharp
int checksum = session.QueryOver<Rectangle>()</p>

<pre><code>.Select(rct =&gt; rct.Height.CheckSum())
.Take(1)
.SingleOrDefault&lt;int&gt;();
</code></pre>

<p>```</p>

<h3>Using multiple properties/columns in a function call</h3>

<p>There isn&rsquo;t an example of this (that I can find) in the NHibernate code base, so I figured I&rsquo;d go ahead and provide one.</p>

<p>Continuing with the <code>checksum</code> example above, what if we wanted to supply some additional columns to the <code>checksum</code> function? At this point it might be wiser to use the strategy outlined in Part 7, but lets expand the <code>CheckSum</code> extension method for the sake of an example.</p>

<p>Here&rsquo;s how the extension method itself needs to change:</p>

<p>```csharp
public static class QueryOverExtensions
{</p>

<pre><code>public static int CheckSum(this object o, params object[] additionalProperties)
{
    throw new NotImplementedException("Must be used inside of a QueryOver query.");
}
</code></pre>

<p>}
```</p>

<p>Note the use of <code>params</code>&mdash;we&rsquo;ve made it possible for the user of our method to supply as many additional properties as they&rsquo;d like.</p>

<p>Here&rsquo;s the new implementation of <code>ProcessCheckSum</code>:</p>

<p>```csharp
public static IProjection ProcessCheckSum(MethodCallExpression methodCallExpression)
{</p>

<pre><code>/* Retrieve the property the extension method was called on as a projection */
IProjection property =
    ExpressionProcessor.FindMemberProjection(methodCallExpression.Arguments[0])
        .AsProjection();

var projections = new List&lt;IProjection&gt; { property };

/* Process the array that's supplied as the second argument in the expression. */
var additionalProperties = (NewArrayExpression)methodCallExpression.Arguments[1];

/* Convert each item in the array into a projection */
IEnumerable&lt;IProjection&gt; additionalProjections =
    additionalProperties.Expressions
        .Select(expr =&gt; 
            ExpressionProcessor.FindMemberProjection(expr).AsProjection());

/* Combine the first projection and the additional ones */
projections.AddRange(additionalProjections);

return Projections.SqlFunction(
    "checksum", NHibernateUtil.Int32, projections.ToArray());
</code></pre>

<p>}
```</p>

<p>The key here is to notice that <code>Arguments[1]</code> is of type <code>NewArrayExpression</code> (because of the second argument being and array). We need to take out the expressions <em>within</em> that array (that&rsquo;s what the LINQ block does) and then supply those projections to <code>Projections.SqlFunction</code>.</p>

<p>Now we can call our extension method with more properties:</p>

<p>```csharp
int checksum = session.QueryOver<Rectangle>(() => rectAlias)</p>

<pre><code>.Select(rct =&gt; rct.Height.CheckSum(rct.Width))
.Take(1)
.SingleOrDefault&lt;int&gt;();
</code></pre>

<p>```</p>

<p>Note that <code>rct.Width</code> could easily be a property referenced with an alias (e.g. <code>rectAlias.Width</code>), even one from another class.</p>

<h2>Summary</h2>

<p>Hopefully this post has been helpful in providing some useful strategies on how to get NHibernate to generate meaningful SQL from a QueryOver query, even when using unmapped properties or methods. Doing this could be hugely helpful when you have existing user-defined functions you need to call, or you&rsquo;d like to use a computed property inside of a query, rather than pull back every item in your table and then filter it.</p>

<p>To summarize:</p>

<ul>
<li>Normally, unmapped properties are unavailable for querying inside of a QueryOver query, since NHibernate does not know how to translate the property into the correct SQL.</li>
<li>You can tell NHibernate what to do with a method or property using the static <code>ExpressionProcessor</code> class and a method that returns an <code>IProjection</code> given an expression containing the method call.</li>
<li>As long as you can represent the SQL you want to generate as some kind of <code>IProjection</code>, you can register any property or method with the <code>ExpressionProcessor</code>.</li>
<li>You can create extension methods or properties that are only available for use inside of a QueryOver query.</li>
<li>Methods can contain a provision for processing an arbitrary number of properties for inclusion in the SQL that&rsquo;s ultimately generated.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QueryOver Series Part 8: Working with Subqueries]]></title>
    <link href="http://www.andrewwhitaker.com/blog/2014/10/24/queryover-series-part-8-working-with-subqueries/"/>
    <updated>2014-10-24T11:17:39-05:00</updated>
    <id>http://www.andrewwhitaker.com/blog/2014/10/24/queryover-series-part-8-working-with-subqueries</id>
    <content type="html"><![CDATA[<p>Subqueries are often extremely useful when building queries. Unfortunately there&rsquo;s not much out there on how to work with subqueries in QueryOver. In this post, I&rsquo;ll dive into how to create the subqueries using QueryOver&rsquo;s various subquery APIs.</p>

<!-- more -->


<p>*This article is part of an ongoing series on NHibernate Queryover. Click [here](/queryover-series) to see the table of contents.*</p>

<p>There are two places you can use subqueries in a QueryOver query: the <code>SELECT</code> clause and the <code>WHERE</code> clause. Unfortunately you cannot use a subquery in the <code>FROM</code> clause of a QueryOver query.</p>

<h2>Subqueries in the <code>WHERE</code> clause</h2>

<p>As usual, there are several ways to generate identical SQL using QueryOver. I&rsquo;ll go over each one in detail.</p>

<h3><code>.WithSubquery</code></h3>

<p><code>.WithSubquery</code> is the most straightforward and natural way to create a subquery with QueryOver. Basically, using <code>.WithSubquery</code> allows you to use some property on <code>TSubType</code> (or a property belonging to an alias) with a subquery expression. After calling <code>.WithSubquery</code>, there are several methods that become available:</p>

<ul>
<li><code>.Where</code></li>
<li><code>.WhereAll</code></li>
<li><code>.WhereSome</code></li>
<li><code>.WhereExists</code></li>
<li><code>.WhereNotExists</code></li>
<li><code>.WhereProperty</code></li>
</ul>


<p>For the most part these are pretty straightforward, but I&rsquo;ll go over each one.</p>

<h4><code>.Where</code></h4>

<p>You should use <code>.WithSubquery.Where</code> when your subquery returns a scalar value and you want to compare that value (using <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, or <code>&lt;=</code>) with a value from your outer query.</p>

<p>For example, here&rsquo;s a query that finds the <code>Product</code> with the <code>Transaction</code> containing the highest quantity (one <code>Product</code> has many <code>Transactions</code>):</p>

<p><strong>QueryOver</strong>:
```csharp
var popularProduct = session.QueryOver<Product>()</p>

<pre><code>.WithSubquery.Where(pr =&gt; pr.Id ==
    QueryOver.Of&lt;TransactionHistory&gt;()
        .Select(tx =&gt; tx.Product.Id)
        .OrderBy(tx =&gt; tx.Quantity)
        .Desc
        .Take(1)
        .As&lt;int&gt;())
.SingleOrDefault&lt;Product&gt;();
</code></pre>

<p>```</p>

<p><strong>SQL</strong>:
```sql
SELECT</p>

<pre><code>*
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>WHERE</p>

<pre><code>this_.ProductID = (
    SELECT
        TOP (1)  this_0_.ProductID as y0_
    FROM
        Production.TransactionHistory this_0_
    ORDER BY
        this_0_.Quantity desc
);
</code></pre>

<p>```</p>

<p>The interesting thing to note about the subquery is the <code>.As&lt;T&gt;</code> method at the end. This allows us to compare the <code>Id</code> property from the outer query with the inner query&rsquo;s <code>Product.Id</code> property. This method&rsquo;s sole purpose is to be used inside of a subquery like this so that we can treat the entire QueryOver query as a scalar value for comparison purposes.</p>

<h4><code>.WhereAll</code> and <code>.WhereSome</code></h4>

<p><code>.WithSubquery.WhereAll</code> and <code>.WithSubquery.WhereSome</code> generate SQL that looks similar to the SQL generated by <code>Where</code>, but it uses the <code>all</code> or <code>some</code> operator to modify the comparison. The subquery should return a resultset of one column. Each row in that result is compared with the scalar value from the outer query.</p>

<p>For example, here&rsquo;s a query that finds all <code>Product</code>s who&rsquo;s <code>ListPrice</code> is greater than <em>all</em> of the related <code>ProductCostHistory</code> entries' <code>StandardCost</code>. <code>ProductCostHistory</code> tracks product cost over time:</p>

<p><strong>QueryOver</strong>
```csharp
Product productAlias = null;
var products = session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.WithSubquery.WhereAll(p =&gt; p.ListPrice &gt;
    QueryOver.Of&lt;ProductCostHistory&gt;()
        .Where(ch =&gt; ch.Product.Id == productAlias.Id)
        .Select(ch =&gt; ch.StandardCost)
        .As&lt;decimal&gt;())
.List&lt;Product&gt;();
</code></pre>

<p>```</p>

<p><strong>SQL</strong>
```sql
SELECT</p>

<pre><code>*
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>WHERE</p>

<pre><code>this_.ListPrice &gt; all (
    SELECT
        this_0_.StandardCost as y0_
    FROM
        Production.ProductCostHistory this_0_
    WHERE
        this_0_.ProductID = this_.ProductID
)
</code></pre>

<p>```</p>

<p>If you look carefully at the QueryOver, you&rsquo;ll notice that I assigned an alias to the outer <code>Product</code>. This is so that I could correlate the outer query and the inner query.</p>

<p>Using <code>.WhereSome</code> instead would generate SQL using the <code>some</code> operator. This operator returns <code>true</code> if <em>at least one</em> of the values in the resultset from the subquery returns true.</p>

<h4><code>.WhereExists</code> and <code>.WhereNotExists</code></h4>

<p>These two are straightforward. These will generate the SQL you&rsquo;d expect with <code>exists</code> or <code>not exists</code>, respectively. If you&rsquo;re familiar with SQL, you&rsquo;ve probably used these a fair amount. Use <code>.WhereExists</code> to return rows where there&rsquo;s at least one result in the subquery, and use <code>.WhereNotExists</code> to return rows where the subquery returns no results.</p>

<p>Here&rsquo;s an example that returns all products with no transaction history:</p>

<p><strong>QueryOver</strong>
```csharp
Product productAlias = null;</p>

<p>var productsWithNoTransactions = session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.WithSubquery.WhereNotExists(
    QueryOver.Of&lt;TransactionHistory&gt;()
        .Where(tx =&gt; tx.Product.Id == productAlias.Id)
        .Select(tx =&gt; tx.Id))
.List&lt;Product&gt;();
</code></pre>

<p>```</p>

<p><strong>SQL</strong>
```sql
SELECT</p>

<pre><code>*
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>WHERE</p>

<pre><code>not exists (
    SELECT
        this_0_.TransactionID as y0_
    FROM
        Production.TransactionHistory this_0_
    WHERE
        this_0_.ProductID = this_.ProductID
)
</code></pre>

<p>```</p>

<p>Using <code>.WithSubquery</code> is the most straightforward way to work with subqueries in the <code>WHERE</code> clause of a query.</p>

<h3>With the <code>Restrictions</code> class</h3>

<p>You can use the <code>Restrictions</code> class to generate SQL within a QueryOver query as well. I won&rsquo;t show everything you can do with the <code>Restrictions</code> class&mdash; it should be pretty straightforward after showing a few examples.</p>

<p>Here&rsquo;s the first example from the previous section:</p>

<p>```csharp
session.QueryOver<Product>()</p>

<pre><code>.Where(
    Restrictions.EqProperty(
        Projections.Property&lt;Product&gt;(pr =&gt; pr.Id),
        Projections.SubQuery(
            QueryOver.Of&lt;TransactionHistory&gt;()
                .Select(tx =&gt; tx.Product.Id)
                .OrderBy(tx =&gt; tx.Quantity)
                .Desc
                .Take(1))))
.SingleOrDefault&lt;Product&gt;();
</code></pre>

<p>```</p>

<p>I&rsquo;m not sure about you, but to me this is much harder to read and looks much more complex than the example in the previous section.</p>

<p>Usually this syntax is not necessary, but you may find it useful if you&rsquo;re building queries dynamically.</p>

<p>One way to build a list of conditions joined by <code>AND</code> operators is to use <code>Restrictions.Conjunction()</code>. You can call <code>.Add</code> on the <code>Conjunction</code> instance you get back, building a conjunction based on various conditions.</p>

<p>Here&rsquo;s an example:</p>

<p>```csharp
Conjunction conjunction = Restrictions.Conjunction();</p>

<p>if (onlyBiggestTransaction)
{</p>

<pre><code>conjunction.Add(
    Restrictions.EqProperty(
        Projections.Property&lt;Product&gt;(pr =&gt; pr.Id),
        Projections.SubQuery(
            QueryOver.Of&lt;TransactionHistory&gt;()
                .Select(tx =&gt; tx.Product.Id)
                .OrderBy(tx =&gt; tx.Quantity)
                .Desc
                .Take(1))));
</code></pre>

<p>}</p>

<p>session.QueryOver<Product>()</p>

<pre><code>.Where(conjunction)
.List&lt;Product&gt;();
</code></pre>

<p>```</p>

<p>If you have lots of conditions you&rsquo;re evaluating to build a <code>WHERE</code> clause, I would consider going this route. It&rsquo;s easy to read the final query (starting on L16 above), and the various parts of the <code>Conjunction</code> are also nicely separated from the main query.</p>

<h2>Subqueries in the <code>SELECT</code> clause</h2>

<p>There are two ways to use subqueries in the <code>SELECT</code> clause: <code>SelectSubquery</code> and <code>Projections.Subquery</code>.</p>

<h3><code>SelectSubquery</code></h3>

<p>If you&rsquo;re using a select list (built using <code>QueryOver&lt;TRoot, TSubType&gt;.SelectList(...)</code>), the easiest way to create a subquery in the <code>SELECT</code> clause is to use <code>.SelectSubquery</code>. This works exactly how you&rsquo;d expect it to.</p>

<p>This example gets information about a <code>Product</code> and the highest <code>ProductReview.Rating</code> associated with that product:</p>

<p><strong>QueryOver</strong>
```csharp
session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.SelectList(list =&gt; list
    .SelectSubQuery(
        QueryOver.Of&lt;ProductReview&gt;()
            .Where(pr =&gt; pr.Product.Id == productAlias.Id)
            .Select(pr =&gt; pr.Rating)
            .OrderBy(pr =&gt; pr.Rating).Desc
            .Take(1))
    .Select(pr =&gt; pr.Id)
    .Select(pr =&gt; pr.Name))
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>Note that I&rsquo;m creating a correlated subquery by assigning <code>productAlias</code> in the outer query and then using it in the subquery.</p>

<p><strong>SQL</strong>
```sql
SELECT</p>

<pre><code>(SELECT
    TOP (1)  this_0_.Rating as y0_
FROM
    Production.ProductReview this_0_
WHERE
    this_0_.ProductID = this_.ProductID
ORDER BY
    this_0_.Rating desc) as y0_,
this_.ProductID as y1_,
this_.Name as y2_
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_;
</code></pre>

<p>```</p>

<h3><code>Projections.Subquery</code></h3>

<p><code>Projections.Subquery</code> can come in handy when building the <code>SELECT</code> clause dynamically. This is especially useful when you&rsquo;re building a <code>SELECT</code> clause using <code>Projections.ProjectionList</code>. Here&rsquo;s the same query from the <code>SelectSubquery</code> example above:</p>

<p>```csharp
session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.Select(Projections.ProjectionList()
    .Add(Projections.SubQuery(
        QueryOver.Of&lt;ProductReview&gt;()
            .Where(pr =&gt; pr.Product.Id == productAlias.Id)
            .Select(pr =&gt; pr.Rating)
            .OrderBy(pr =&gt; pr.Rating)
            .Desc
            .Take(1)))
    .Add(Projections.Property(() =&gt; productAlias.Id))
    .Add(Projections.Property(() =&gt; productAlias.Name)))
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<h2>Refactoring tip</h2>

<p>Working with subqueries in QueryOver can quickly become overwhelming, especially if you&rsquo;re building a complex query.</p>

<p>One great way to easily make things a bit more readable is to simply store subquery definitions in variables. Keeping with the same example:</p>

<p>```csharp
Product productAlias = null;</p>

<p>// Store the reviews subquery in a variable
QueryOver<ProductReview> reviewSubquery =</p>

<pre><code>QueryOver.Of&lt;ProductReview&gt;()
    .Where(pr =&gt; pr.Product.Id == productAlias.Id)
    .Select(pr =&gt; pr.Rating)
    .OrderBy(pr =&gt; pr.Rating)
    .Desc
    .Take(1);
</code></pre>

<p>// use that variable in the main query
session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.Select(Projections.ProjectionList()
    .Add(Projections.SubQuery(reviewSubquery))
    .Add(Projections.Property(() =&gt; productAlias.Id))
    .Add(Projections.Property(() =&gt; productAlias.Name)))
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>That&rsquo;s an easy improvement to make, especially when you&rsquo;re dealing with larger queries.</p>

<h2>Summary</h2>

<p>Working with subqueries can quickly become overwhelming with QueryOver. Hopefully this post will help you write and maintain more advanced QueryOver queries involving subqueries. To summarize:</p>

<ul>
<li>With QueryOver you can use subqueries in the <code>SELECT</code> clause or the <code>WHERE</code> clause. Unfortunately you cannot query from a derived table in the <code>FROM</code> clause</li>
<li>In the <code>WHERE</code> clause, you can use <code>.WithSubquery</code>, followed by a <code>.Where</code> variety to control how the results of the subquery are treated</li>
<li>You can also use the <code>Restrictions</code> class along with <code>Projections.Subquery</code></li>
<li>In the <code>SELECT</code> clause, you can use <code>.SelectSubQuery</code> with <code>.SelectList</code>.</li>
<li>You can also use <code>Projections.Subquery</code> to  generate a subquery in the <code>SELECT</code> clause.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QueryOver Series - Part 7: Using SQL Functions]]></title>
    <link href="http://www.andrewwhitaker.com/blog/2014/08/15/queryover-series-part-7-using-sql-functions/"/>
    <updated>2014-08-15T14:46:35-05:00</updated>
    <id>http://www.andrewwhitaker.com/blog/2014/08/15/queryover-series-part-7-using-sql-functions</id>
    <content type="html"><![CDATA[<p>In this post, I&rsquo;ll go over how to use functions built into the database engine. This can be useful when you want to do some work inside of your SQL query rather than do post-processing on the result set you get back.</p>

<!-- more -->


<p>*This article is part of an ongoing series on NHibernate Queryover. Click [here](/queryover-series) to see the table of contents.*</p>

<h2>Dialects in NHibernate</h2>

<p>To understand how to use and later build SQL functions, it&rsquo;s helpful to understand how the default SQL functions are registered with NHibernate to begin with.</p>

<p>NHibernate has the concept of a SQL <em>dialect</em>, a vendor-specific flavor of SQL. As you probably know, <a href="http://www.nhforge.org/doc/nh/en/#configuration-optional-dialects">many dialects are supported out of the box</a>. NHibernate represents dialects with a class per supported dialect.</p>

<p>The <code>Dialect</code> base class registers required functions for a dialect using ANSI-92 standards. If a dialect implements a function differently, that dialect must overwrite the base class' implementation with its own.</p>

<p>For example, SQL Server doesn&rsquo;t implement the ANSI-92 <code>TRIM</code> function, so the <code>MsSql2000</code> dialect class uses a different implementation than the base class (which ultimately calls <code>rtrim</code> and <code>ltrim</code> to simulate the ANSI standard).</p>

<p>It&rsquo;s worth looking over the <code>Dialect</code> base class and possibly the dialect class for the database engine you&rsquo;re using to see what functions are already available to you.</p>

<h2>Calling functions from your queries</h2>

<p>There are two ways to actually use SQL functions inside of your queries.</p>

<h3>Using <code>Projections.SqlFunction</code></h3>

<p>Using already registered SQL functions is fairly simple, using <code>Projections.SqlFunction</code>. For example, here&rsquo;s a query that gets every <code>Person</code>&rsquo;s middle name, or &ldquo;Not Applicable&rdquo; if <code>MiddleName</code> is <code>null</code>, using the <code>COALESCE</code> function:</p>

<p><strong>QueryOver</strong>:
```csharp
IList<string> middleNames = session.QueryOver<Person>()</p>

<pre><code>.Select(
    Projections.SqlFunction("coalesce", NHibernateUtil.String,
        Projections.Property&lt;Person&gt;(p =&gt; p.MiddleName),
        Projections.Constant("Not Applicable"))
)
.List&lt;string&gt;();
</code></pre>

<p>```</p>

<p><strong>SQL</strong>:
```sql
SELECT</p>

<pre><code>COALESCE (this_.MiddleName, 'Not Applicable') AS y0_ 
</code></pre>

<p>FROM</p>

<pre><code>Person.Person this_ 
</code></pre>

<p>```</p>

<p>This same pattern applies to all SQL functions that you&rsquo;d like to call using <code>Projections.SqlFunction</code>.</p>

<h3>Using <code>ProjectionsExtensions</code></h3>

<p>Inside of a QueryOver query, there&rsquo;s actually a better way to call many of the most common SQL functions. The <code>ProjectionsExtensions</code> class inside of the <code>NHibernate.Criterion</code> namespace contains extension methods that are parsed into SQL function calls.</p>

<p>For example, here&rsquo;s a query using the <code>.Upper</code> extension method. Note that these extension methods are actually on the object&rsquo;s properties:</p>

<p><strong>QueryOver</strong>:
```csharp
IList<string> middleNames = session.QueryOver<Person>()</p>

<pre><code>.Select(p =&gt; p.FirstName.Upper())
.List&lt;string&gt;();
</code></pre>

<p>```</p>

<p><strong>SQL</strong>:
```sql
SELECT</p>

<pre><code>UPPER (this_.FirstName) AS y0_ 
</code></pre>

<p>FROM</p>

<pre><code>Person.Person this_ 
</code></pre>

<p>```</p>

<p>This is much cleaner than the alternative using <code>Projections.SqlFunction</code>:</p>

<p>```csharp
IList<string> names = session.QueryOver<Person>()</p>

<pre><code>.Select(
    Projections.SqlFunction(
        "upper",
        NHibernateUtil.String,
        Projections.Property&lt;Person&gt;(p =&gt; p.FirstName)))
.List&lt;string&gt;();
</code></pre>

<p>```</p>

<h2>Using your own functions</h2>

<p>In most cases, functions you want to use will already be registered in the dialect you&rsquo;re using. In some cases, however, you&rsquo;ll want to add a function that&rsquo;s not been registered. In this section of the post, I&rsquo;ll go over how to add the <code>checksum</code> function in SQL Server. There are a few steps involved in using your own function, I&rsquo;ll go over each one in detail.</p>

<p>There are actually two ways to invoke a custom SQL function from your queries. You can either add the function &ldquo;statically&rdquo; to a custom dialect, or invoke a brand new function &ldquo;dynamically&rdquo; at runtime that&rsquo;s not registered with the dialect.</p>

<h3>Adding your own dialect</h3>

<p>As I discussed earlier, functions are registered in the dialect class representing the database flavor you&rsquo;re using. Since we can&rsquo;t modify those classes directly to register our function, we&rsquo;ll create a new dialect that&rsquo;s a subclass of the one we&rsquo;re using.</p>

<p>Since I&rsquo;m using SQL Server in this example, I&rsquo;ll create a custom dialect that&rsquo;s a subclass of <code>MsSql2012Dialect</code>.</p>

<p>```csharp
using NHibernate;
using NHibernate.Dialect;
using NHibernate.Dialect.Function;</p>

<p>public class AdventureWorksDialect : MsSql2012Dialect
{</p>

<pre><code>public AdventureWorksDialect()
{
    this.RegisterFunction("checksum", new StandardSQLFunction("checksum", NHibernateUtil.Int32));
}
</code></pre>

<p>}
```</p>

<p>Then, we need to make sure our application is using the new dialect. We can do this either in our configuration code:</p>

<p>```csharp
var cfg = new Configuration()</p>

<pre><code>.Configure()
.DataBaseIntegration(db =&gt;
{
    db.Dialect&lt;AdventureWorksDialect&gt;();
});
</code></pre>

<p>```</p>

<p>Or, in our config file:</p>

<p>```xml
&lt;hibernate-configuration xmlns=&ldquo;urn:nhibernate-configuration-2.2&rdquo;>
  &lt;session-factory></p>

<pre><code>&lt;property name="show_sql"&gt;false&lt;/property&gt;
&lt;property name="connection.driver_class"&gt;NHibernate.Driver.Sql2008ClientDriver&lt;/property&gt;
&lt;property name="dialect"&gt;AdventureWorks.Database.AdventureWorksDialect&lt;/property&gt;
&lt;property name="connection.connection_string_name"&gt;AdventureWorks&lt;/property&gt;
</code></pre>

<p>  &lt;/session-factory>
&lt;/hibernate-configuration>
```</p>

<h4>Calling the function using <code>Projections.SqlFunction</code></h4>

<p>If all you want to do is call a function using <code>Projections.SqlFunction</code>, you&rsquo;re basically done. All you need to do is call the function:</p>

<p>```csharp
IList<int> checksums = session.QueryOver<Product>()</p>

<pre><code>.Select(Projections.SqlFunction(
    "checksum",
    NHibernateUtil.Int32,
    Projections.Property&lt;Product&gt;(p =&gt; p.Id),
    Projections.Property&lt;Product&gt;(p =&gt; p.Name)))
.List&lt;int&gt;();
</code></pre>

<p>```</p>

<p>This will yield the following SQL:</p>

<p>```sql
SELECT</p>

<pre><code>CHECKSUM (this_.ProductID, this_.Name) AS y0_ 
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_ 
</code></pre>

<p>```</p>

<h4>Creating a custom projections class</h4>

<p>Using <code>Projections.SqlFunction</code> isn&rsquo;t quite satisfactory, especially after seeing the built-in <code>ProjectionExtensions</code>. We can easily create a <code>CustomProjections</code> class that provides some syntactic sugar for calling our custom function:</p>

<p>```csharp
public static class CustomProjections
{</p>

<pre><code>public static IProjection Checksum(params Expression&lt;Func&lt;object&gt;&gt;[] properties)
{
    return Checksum(properties.Select(Projections.Property).ToArray());
}

public static IProjection Checksum(params IProjection[] projections)
{
    return Projections.SqlFunction("checksum", NHibernateUtil.Int32, projections);
}
</code></pre>

<p>}
```</p>

<p>Notice that we have two overloads of <code>Checksum</code>, one that takes an array of <code>Expression&lt;Func&lt;object&gt;&gt;</code>s and another that takes an array of <code>IProjection</code>s.</p>

<p>Using the <code>Expression&lt;Func&lt;object&gt;&gt;[]</code> overload is convenient when we don&rsquo;t need to combine the use of <code>checksum</code> with other functions, for example:</p>

<p>```csharp
IList<int> checksums = session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.Select(CustomProjections.Checksum(
    () =&gt; productAlias.Name,
    () =&gt; productAlias.Id))
.List&lt;int&gt;();
</code></pre>

<p>```</p>

<p>Using the <code>IProjection[]</code> overload is useful when we need to supply <code>checksum</code> with the result of calling <em>another</em> function, say <code>avg</code>:</p>

<p><code>``csharp
// Get the</code>checksum` of the average price for each sell start date.
IList&lt;object[]> checksums = session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.SelectList(list =&gt; list
    .SelectGroup(p =&gt; p.SellStartDate)
    .Select(
        CustomProjections.Checksum(
            Projections.Avg(
                Projections.Property(() =&gt; productAlias.ListPrice)))
    ))
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<h4><code>StandardSQLFunction</code> and <code>SQLFunctionTemplate</code></h4>

<p>If you look through <a href="https://github.com/nhibernate/nhibernate-core/tree/master/src/NHibernate/Dialect/Function">NHibernate&rsquo;s implementations of various SQL functions</a>, you might notice that many use <code>StandardSQLFunction</code> and <code>SQLFunctionTemplate</code>. These should take care of most of your custom function needs. If not, you can always implement <code>ISQLFunction</code> and create your own implementation.</p>

<h5><code>StandardSQLFunction</code></h5>

<p>We used <code>StandardSQLFunction</code> to implement our <code>checksum</code> example. Basically, <code>StandardSQLFunction</code> allows you to implement a SQL function that takes an arbitrary number of arguments and returns a scalar value.</p>

<h5><code>SQLFunctionTemplate</code></h5>

<p><code>SQLFunctionTemplate</code> is a bit more sophisticated, and you can use it to implement SQL functions with a <em>template</em>, like the name implies. This is typically useful when you want to require a function to have a specific number of arguments.</p>

<p>An example of this would be the <code>stuff</code> <a href="http://msdn.microsoft.com/en-us/library/ms188043.aspx">function in SQL Server</a>. This function inserts one string into another string, deleting the specified number of characters from the first string at a start index, then inserts the second string.</p>

<p>For example, here&rsquo;s how you could use <code>stuff</code> to replace &ldquo;C++&rdquo; with &ldquo;C#&rdquo;:</p>

<p><code>csharp
select stuff('C++', 2, 2, '#')
</code></p>

<p>Since <code>stuff</code> has a fixed number of parameters, it&rsquo;s a good candidate for <code>SQLFunctionTemplate</code>. All we have to do to register it in our dialect is add the following line:</p>

<p><code>csharp
this.RegisterFunction("stuff", new SQLFunctionTemplate(NHibernateUtil.Int32, "stuff(?1, ?2, ?3, ?4)"));
</code></p>

<p>Here, we&rsquo;re basically just saying that <code>stuff</code> is a function whose syntax is invoking the <code>stuff</code> function with exactly four parameters.</p>

<p>We&rsquo;ll add a few more static methods to our <code>CustomProjections</code> class, since there are several ways we might want to call this function, we&rsquo;ll provide several overloads:</p>

<p>```csharp
// Usage: CustomProjections.Stuff(() => alias.Property, 1, 2, () => alias.OtherProperty)
public static IProjection Stuff(Expression&lt;Func<object>> characterExpression, int start, int length, Expression&lt;Func<object>> replaceWithExpression)
{</p>

<pre><code>return Stuff(Projections.Property(characterExpression), start, length, Projections.Property(replaceWithExpression));
</code></pre>

<p>}</p>

<p>// Usage: CustomProjections.Stuff(Projections.Property(..), 1, 2, Projections.Constant(&hellip;))
public static IProjection Stuff(IProjection characterExpression, int start, int length, IProjection replaceWithExpression)
{</p>

<pre><code>return Projections.SqlFunction("stuff", NHibernateUtil.String, characterExpression, Projections.Constant(start), Projections.Constant(length), replaceWithExpression);
</code></pre>

<p>}</p>

<p>// Usage: CustomProjections.Stuff(() => alias.Property, 1, 2, &ldquo;Replacement&rdquo;)
public static IProjection Stuff(Expression&lt;Func<object>> characterExpression, int start, int length, string replaceWithExpression)
{</p>

<pre><code>return Stuff(Projections.Property(characterExpression), start, length, Projections.Constant(replaceWithExpression));
</code></pre>

<p>}
```</p>

<p>Here&rsquo;s an example of how it would be used:</p>

<p>```csharp
IList<string> stuffResults = session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.SelectList(list =&gt; list
    .Select(
        CustomProjections.Stuff(() =&gt; productAlias.Name, 0, 2, "PR")
    ))
.List&lt;string&gt;();
</code></pre>

<p>```</p>

<h3>Invoking new functions at runtime</h3>

<p>If, for some reason, you don&rsquo;t want to create a custom dialect and register functions there, you can still invoke an unregistered SQL function. There&rsquo;s an overload of <code>Projections.SqlFunction</code> that takes an <code>ISQLFunction</code> that you can define at runtime. For example, if we had not registered our <code>checksum</code> function, you could call it dynamically like this:</p>

<p>```csharp
Projections.SqlFunction(</p>

<pre><code>new StandardSQLFunction("checksum"),
NHibernateUtil.Int32,
Projections.Property(() =&gt; productAlias.Name),
Projections.Property(() =&gt; productAlias.Id)
</code></pre>

<p>```</p>

<p>Here, we&rsquo;re defining and using the <code>checksum</code> function in one shot.</p>

<p>There <em>is</em> a disadvantage to using this method. When you register a function with the dialect instead, NHibernate adds the function to an internal cache and reuses the function definition whenever you access it by name.</p>

<p>Creating a new <code>checksum</code> function every time we needed to call the SQL Server <code>checksum</code> function would be wasteful&mdash;it would be better to define the function once and have NHibernate cache and reuse it.</p>

<p>However, we may want to leverage invoking a function dynamically to take care of special SQL functions, like SQL Server&rsquo;s <code>datediff</code> function.</p>

<h4>Implementing SQL Server&rsquo;s <code>datediff</code> function.</h4>

<p>SQL Server has a <a href="http://msdn.microsoft.com/en-us/library/ms189794%28SQL.90%29.aspx">function</a> called <code>datediff</code> that returns the number of &ldquo;date parts&rdquo; between a given start and end date.</p>

<p>At first glance, it seems like we could register <code>datediff</code> using <code>SQLFunctionTemplate</code>:</p>

<p><code>csharp
new SQLFunctionTemplate("datediff(?1, ?2, ?3)")
</code></p>

<p>The problem here is that <code>datediff</code>&rsquo;s first parameter is a SQL server keyword and <em>cannot</em> be supplied as a variable. According to MSDN:</p>

<blockquote><p>These dateparts and abbreviations cannot be supplied as a user-declared variable.</p></blockquote>

<p>So that means we can&rsquo;t call <code>datediff</code> and supply the <code>datepart</code> dynamically. We could register a function for every possible version of <code>datediff</code> and name them all slightly differently:</p>

<p><code>csharp
RegisterFunction("datediff-yr", new SQLFunctionTemplate("datediff(yy, ?1, ?2)"));
RegisterFunction("datediff-dd", new SQLFunctionTemplate("datediff(dd, ?1, ?2)"));
/* etc, for each valid datepart */
</code></p>

<p>I&rsquo;m not sure about you but this makes me cringe. Luckily there&rsquo;s a better solution. We can use NHibernate&rsquo;s ability to run an arbitrary, unregistered SQL function to dynamically create and execute the various versions of <code>datediff</code>. Here&rsquo;s the code:</p>

<p>```csharp
public static class DateProjections
{</p>

<pre><code>private const string DateDiffFormat = "datediff({0}, ?1, ?2)";

public static IProjection DateDiff(
    string datepart, 
    Expression&lt;Func&lt;object&gt;&gt; startDate, 
    Expression&lt;Func&lt;object&gt;&gt; endDate)
{
    // Build the function template based on the date part.
    string functionTemplate = string.Format(DateDiffFormat, datepart);

    return Projections.SqlFunction(
        new SQLFunctionTemplate(NHibernateUtil.Int32, functionTemplate),
        NHibernateUtil.Int32,
        Projections.Property(startDate),
        Projections.Property(endDate));
}
</code></pre>

<p>}
```</p>

<p>Now, we&rsquo;re able to write queries using any date part we want without having to register a separate function for each date part. For example, here&rsquo;s a query that gets the <code>datediff</code> in days, quarters, and months:</p>

<p>```csharp
IList&lt;object[]> checksums = session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.SelectList(list =&gt; list
    .Select(DateProjections.DateDiff("dd", () =&gt; productAlias.SellStartDate, () =&gt; productAlias.SellEndDate))
    .Select(DateProjections.DateDiff("qq", () =&gt; productAlias.SellStartDate, () =&gt; productAlias.SellEndDate))
    .Select(DateProjections.DateDiff("mm", () =&gt; productAlias.SellStartDate, () =&gt; productAlias.SellEndDate)))
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>This still isn&rsquo;t perfect. You might have realized that we&rsquo;re still at a disadvantage since we&rsquo;re not using cached versions of our function definitions. One good solution to this is to use our own cache for the various <code>datediff</code> flavors. Here&rsquo;s what our class looks like with that modification:</p>

<p>```csharp
public static class DateProjections
{</p>

<pre><code>private const string DateDiffFormat = "datediff({0}, ?1, ?2)";

// Maps datepart to an ISQLFunction
private static Dictionary&lt;string, ISQLFunction&gt; DateDiffFunctionCache = 
    new Dictionary&lt;string, ISQLFunction&gt;();

public static IProjection DateDiff(
    string datepart, 
    Expression&lt;Func&lt;object&gt;&gt; startDate, 
    Expression&lt;Func&lt;object&gt;&gt; endDate)
{
    ISQLFunction sqlFunction = GetDateDiffFunction(datepart);

    return Projections.SqlFunction(
        sqlFunction,
        NHibernateUtil.Int32,
        Projections.Property(startDate),
        Projections.Property(endDate));
}

private static ISQLFunction GetDateDiffFunction(string datepart)
{
    ISQLFunction sqlFunction;

    if (!DateDiffFunctionCache.TryGetValue(datepart, out sqlFunction))
    {
        string functionTemplate = string.Format(DateDiffFormat, datepart);
        sqlFunction = new SQLFunctionTemplate(NHibernateUtil.Int32, functionTemplate);

        DateDiffFunctionCache[datepart] = sqlFunction;
    }

    return sqlFunction;
}
</code></pre>

<p>}
```</p>

<p>Now we&rsquo;re caching our function definitions so that we&rsquo;re not redefining versions of <code>datediff</code> unnecessarily.</p>

<p>Another enhancement that probably should be made is to make the <code>datepart</code> argument of <code>DateProjections.DateDiff</code> strongly typed. A good solution there would be to use an <code>enum</code> defining the possible <code>datepart</code> values. Then you could use a <code>Dictionary&lt;DatePart, string&gt;</code> to map from <code>enum</code> values to strings.</p>

<h2>Summary</h2>

<p>Calling built-in SQL functions from NHibernate queries has been written about many times before, but hopefully I was able to shed some light on how those functions are registered and invoked. In summary:</p>

<ul>
<li>You can either register a function by using a custom dialect and invoke it by name later, or define and invoke the function in one step.</li>
<li>Registering a function with a custom dialect is often the best option since the function definition is cached and reused automatically by NHibernate.</li>
<li><code>StandardSQLFunction</code> and <code>SQLFunctionTemplate</code> are implementations of <code>ISQLFunction</code> that enable easily defining SQL functions.</li>
<li>Using a custom projections class is a useful abstraction to lay on top of <code>Projections.SqlFunction</code> to make code easier to read and more robust.</li>
<li>You can use NHibernate&rsquo;s ability to call SQL functions at runtime to implement the <code>datediff</code> function in a clean way.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QueryOver Series - Part 6: Query Building Techniques]]></title>
    <link href="http://www.andrewwhitaker.com/blog/2014/08/07/queryover-series-part-6-query-building-techniques/"/>
    <updated>2014-08-07T16:05:37-05:00</updated>
    <id>http://www.andrewwhitaker.com/blog/2014/08/07/queryover-series-part-6-query-building-techniques</id>
    <content type="html"><![CDATA[<p>In this post, I&rsquo;m going to explain some more advanced techniques for building queries with QueryOver. Practically, this means adding joins and where clauses dynamically. This is actually one of the most powerful abilities of QueryOver so it&rsquo;s worth understanding.</p>

<!-- more -->


<p>*This article is part of an ongoing series on NHibernate Queryover. Click [here](/queryover-series) to see the table of contents.*</p>

<p>To make this easier to explain, I&rsquo;m going to use a simple example that I can build on throughout the post.</p>

<h2>The Problem</h2>

<p>Imagine your company is building a page that lists all of the company&rsquo;s available products. On the left hand side, there are a few different filters the user can use to narrow his or her search.</p>

<p>You&rsquo;re immediately faced with a problem: How do I conditionally add where clauses and joins depending on the user&rsquo;s filters? If you&rsquo;re using a pure SQL solution, you would most likely need to build up dynamic SQL and then execute that. This will work fine, but you&rsquo;re immediately faced with a few other problems:</p>

<ul>
<li><strong>You&rsquo;re more open to SQL injection</strong>. Instead of using a parameterized query, a programmer could modify your query to concatenate user-inputted data into the query.</li>
<li><strong>You have a big maintainability problem</strong>. You&rsquo;re going to have to deal with giant strings of SQL. This isn&rsquo;t fun to read or modify.</li>
</ul>


<p>Both of these problems apply whether you&rsquo;re building the SQL in a stored procedure or if you&rsquo;re building SQL outside of the database engine (say, in your application layer).</p>

<h2>Solutions with QueryOver</h2>

<p>Using QueryOver to dynamically build queries is an attractive solution because it solves both problems:</p>

<ul>
<li>NHibernate is building the SQL behind the scenes using parameterized queries, so we don&rsquo;t have to worry about SQL injection.</li>
<li>Instead of looking at huge amounts of string concatenation, we&rsquo;re looking at more expressive .NET code. As a bonus, this is compiled with our application making it much more maintainable.</li>
</ul>


<p>Lets take a look at how we can dynamically construct queries with QueryOver. Keeping with our example, we&rsquo;ll start with a base query that retrieves information about all products:</p>

<p>Here&rsquo;s the DTO we&rsquo;re projecting to with our queries:</p>

<p>```csharp
public class ProductDTO
{</p>

<pre><code>public string Name { get; set; }

public string Color { get; set; }

public decimal ListPrice { get; set; }
</code></pre>

<p>}
```</p>

<p>And here&rsquo;s the basic query we&rsquo;ll be building on:</p>

<p>```csharp
IList<ProductDTO> products = session.QueryOver<Product>()</p>

<pre><code>.SelectList(list =&gt; list
    .Select(pr =&gt; pr.Name).WithAlias(() =&gt; result.Name)
    .Select(pr =&gt; pr.Color).WithAlias(() =&gt; result.Color)
    .Select(pr =&gt; pr.ListPrice).WithAlias(() =&gt; result.ListPrice))
.TransformUsing(Transformers.AliasToBean&lt;ProductDTO&gt;())
.List&lt;ProductDTO&gt;();
</code></pre>

<p>```</p>

<h3>Conditional Restrictions</h3>

<p>Continuing with our example, imagine we have a &ldquo;Color&rdquo; filter where the user can look for products only matching the colors they specify. Since <code>Product.Color</code> is a <code>string</code>, we&rsquo;ll introduce an <code>IEnumerable&lt;string&gt;</code> containing user-specified colors.</p>

<p>Adding this to our query gives us the following:</p>

<p>```csharp
ProductDTO result = null;</p>

<p>var query = session.QueryOver<Product>();</p>

<p>if (colors != null &amp;&amp; colors.Any())
{</p>

<pre><code>query.Where(pr =&gt; pr.Color.IsIn(colors.ToArray()));
</code></pre>

<p>}</p>

<p>IList<ProductDTO> products = query</p>

<pre><code>.SelectList(list =&gt; list
    .Select(pr =&gt; pr.Name).WithAlias(() =&gt; result.Name)
    .Select(pr =&gt; pr.Color).WithAlias(() =&gt; result.Color)
    .Select(pr =&gt; pr.ListPrice).WithAlias(() =&gt; result.ListPrice))
.TransformUsing(Transformers.AliasToBean&lt;ProductDTO&gt;())
.List&lt;ProductDTO&gt;();
</code></pre>

<p>```</p>

<p>Our query has gotten a little more complicated, but it&rsquo;s still readable. Later on in the post, I&rsquo;ll show one way you can make this a bit more readable.</p>

<h3>Conditional Joins</h3>

<p>Sometimes you&rsquo;ll need to conditionally perform a join. One reason for this would be that a query <em>without</em> the join performs much better and you don&rsquo;t want to join unless you have to.</p>

<p>Lets add another filter to our example. Each <code>Product</code> in our domain has 0 to many <code>ProductReview</code>s. Let&rsquo;s add a filter that allows the user to find only products with a minimum user rating. For example, this would let a user find only products that have at least one rating of 3 stars or higher.</p>

<p>We&rsquo;ll add a <code>minimumRating</code> (a <code>Nullable&lt;int&gt;</code> where <code>null</code> indicates that the filter is not being used) and incorporate that into our query:</p>

<p>```csharp
ProductDTO result = null;</p>

<p>var query = session.QueryOver<Product>();</p>

<p>if (colors != null &amp;&amp; colors.Any())
{</p>

<pre><code>query.Where(pr =&gt; pr.Color.IsIn(colors.ToArray()));
</code></pre>

<p>}</p>

<p>if (minimumRating.HasValue)
{</p>

<pre><code>ProductReview reviewAlias = null;
query.JoinAlias(pr =&gt; pr.Reviews, () =&gt; reviewAlias)
    .Where(() =&gt; reviewAlias.Rating &gt;= minimumRating.Value);
</code></pre>

<p>}</p>

<p>IList<ProductDTO> products = query</p>

<pre><code>.SelectList(list =&gt; list
    .Select(pr =&gt; pr.Name).WithAlias(() =&gt; result.Name)
    .Select(pr =&gt; pr.Color).WithAlias(() =&gt; result.Color)
    .Select(pr =&gt; pr.ListPrice).WithAlias(() =&gt; result.ListPrice))
.TransformUsing(Transformers.AliasToBean&lt;ProductDTO&gt;())
.List&lt;ProductDTO&gt;();
</code></pre>

<p>```</p>

<p>This is still more readable than dynamic SQL, but it&rsquo;s starting to look hairy. If we were to add a few more filters we&rsquo;d have a mess on our hands.</p>

<h3>Refactoring into Extension Methods</h3>

<p>One way to apply our filters conditionally is to use <a href="http://msdn.microsoft.com/en-us/library/bb383977.aspx">extension methods</a>. This will allow us to retain the flow of the QueryOver query so that it&rsquo;s a little easier to read.</p>

<p>Here&rsquo;s a static class containing our extension methods:</p>

<p>```csharp
public static class ProductQueryExtensions
{</p>

<pre><code>public static IQueryOver&lt;Product, Product&gt; ApplyColorFilter(
    this IQueryOver&lt;Product, Product&gt; query,
    IEnumerable&lt;string&gt; colors)
{
    if (colors != null &amp;&amp; colors.Any())
    {
        query.Where(pr =&gt; pr.Color.IsIn(colors.ToArray()));
    }

    return query;
}

public static IQueryOver&lt;Product, Product&gt; ApplyRatingFilter(
    this IQueryOver&lt;Product, Product&gt; query,
    int? minimumRating)
{
    if (minimumRating.HasValue)
    {
        ProductReview reviewAlias = null;

        query.JoinAlias(pr =&gt; pr.Reviews, () =&gt; reviewAlias)
            .Where(() =&gt; reviewAlias.Rating &gt;= minimumRating.Value);
    }

    return query;
}
</code></pre>

<p>}
```</p>

<p>And here&rsquo;s our updated query using those extension methods:</p>

<p>```csharp
IList<ProductDTO> products = session.QueryOver<Product>()</p>

<pre><code>.ApplyColorFilter(colors)
.ApplyRatingFilter(minimumRating)
.SelectList(list =&gt; list
    .Select(pr =&gt; pr.Name).WithAlias(() =&gt; result.Name)
    .Select(pr =&gt; pr.Color).WithAlias(() =&gt; result.Color)
    .Select(pr =&gt; pr.ListPrice).WithAlias(() =&gt; result.ListPrice))
.TransformUsing(Transformers.AliasToBean&lt;ProductDTO&gt;())
.List&lt;ProductDTO&gt;();
</code></pre>

<p>return products;
```</p>

<p>This is <em>much</em> easier to read and our filtering logic is in it&rsquo;s own class. As a bonus, it&rsquo;s reusable: we can reuse those same extension methods in another area of our application if we need to.</p>

<p>There are a few problems with this approach though&mdash;so let&rsquo;s address those.</p>

<h4>The extension methods only work on an <code>IQueryOver&lt;Product, Product&gt;</code></h4>

<p>This may not seem like a problem at first, but imagine we changed our query to start at another table. Say, for example, we wanted to start at <code>ProductReview</code> and <em>join</em> to <code>Product</code> instead of <em>starting</em> at <code>Product</code>. In that case, our extension methods would be useless since we aren&rsquo;t working with an <code>IQueryOver&lt;Product, Product&gt;</code> anymore, we&rsquo;re working with an <code>IQueryOver&lt;ProductReview, Product&gt;</code>.</p>

<p>The solution to this problem is to slightly change our extension methods to take advantage of the fact that when we&rsquo;re filtering we only care about <code>TSubType</code> (see <a href="../../../../2014/03/16/queryover-series-part-2-basics/">part 2, Basics and Joining</a> if you need a refresher on <code>TRoot</code> and <code>TSubType</code>):</p>

<p>```csharp
public static class ProductQueryExtensions
{</p>

<pre><code>public static IQueryOver&lt;TRoot, Product&gt; ApplyColorFilter&lt;TRoot&gt;(
    this IQueryOver&lt;TRoot, Product&gt; query,
    IEnumerable&lt;string&gt; colors)
{
    if (colors != null &amp;&amp; colors.Any())
    {
        query.Where(pr =&gt; pr.Color.IsIn(colors.ToArray()));
    }

    return query;
}

public static IQueryOver&lt;TRoot, Product&gt; ApplyRatingFilter&lt;TRoot&gt;(
    this IQueryOver&lt;TRoot, Product&gt; query,
    int? minimumRating)
{
    if (minimumRating.HasValue)
    {
        ProductReview reviewAlias = null;

        query.JoinAlias(pr =&gt; pr.Reviews, () =&gt; reviewAlias)
            .Where(() =&gt; reviewAlias.Rating &gt;= minimumRating.Value);
    }

    return query;
}
</code></pre>

<p>}
```</p>

<p>Now our extension methods will work on any QueryOver query whose <code>TSubType</code> is <code>Product</code>.</p>

<h4>Aliases may need to be passed around</h4>

<p>This is a more subtle problem and requires some understanding of how NHibernate generates SQL from QueryOver code.</p>

<p>Remember that QueryOver is built on top of the Criteria API for querying, and is really just a strongly-typed wrapper for that API using <a href="http://msdn.microsoft.com/en-us/library/bb397951.aspx">expression trees</a>.</p>

<p>What this means for aliases is that NHibernate is using the name of the variable you&rsquo;re using as an alias&mdash;parsing the expression you pass <code>.JoinAlias</code> or <code>.JoinQueryOver</code> into a <code>string</code> that&rsquo;s used with the QueryOver query&rsquo;s underlying criteria query.</p>

<p>This is easiest to see with an example.</p>

<p>Here&rsquo;s an example QueryOver query and its underlying Criteria query, as well as the SQL that&rsquo;s ultimately generated:</p>

<p><strong>QueryOver</strong>:</p>

<p>```csharp
session.QueryOver<Product>()</p>

<pre><code>.JoinQueryOver(pr =&gt; pr.Reviews, () =&gt; reviewAlias)
.SelectList(list =&gt; list
    .SelectGroup(pr =&gt; pr.Id)
    .SelectMax(() =&gt; reviewAlias.Rating))
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p><strong>Criteria</strong>:</p>

<p>```csharp
session.CreateCriteria(typeof(Product))</p>

<pre><code>.CreateCriteria("Reviews", "reviewAlias")
.SetProjection(Projections.ProjectionList()
    .Add(Projections.GroupProperty("Id"))
    .Add(Projections.Max("reviewAlias.Rating")))
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>These generate <em>identical</em> SQL:</p>

<p>```sql
SELECT</p>

<pre><code>this_.ProductID AS y0_, 
MAX (reviewalia1_.Rating) AS y1_ 
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_ 
INNER JOIN Production.ProductReview reviewalia1_ ON 
    this_.ProductID = reviewalia1_.ProductID 
</code></pre>

<p>GROUP BY</p>

<pre><code>this_.ProductID 
</code></pre>

<p>```</p>

<p>The main thing to notice here is that the <em>name</em> of the alias (<code>reviewAlias</code>) we used in the QueryOver query is turned into a <code>string</code> which is ultimately used in the SQL query (<code>reviewalia1_</code>).</p>

<p>What this means is that you <strong>cannot</strong> write code like this:</p>

<p>```csharp
var query = session.QueryOver<Product>()</p>

<pre><code>.JoinAlias(pr =&gt; pr.Reviews, () =&gt; reviewAlias);
</code></pre>

<p>FilterQueryByRating(query, reviewAlias);</p>

<p>query</p>

<pre><code>.SelectList(list =&gt; list
    .SelectGroup(pr =&gt; pr.Id)
    .SelectMax(() =&gt; reviewAlias.Rating))
.List&lt;object[]&gt;();
</code></pre>

<p>// Include only products with a rating > 2 <br/>
public static void FilterQueryByRating(</p>

<pre><code>IQueryOver&lt;Product, Product&gt; query, 
ProductReview reviewAlias)
</code></pre>

<p>{</p>

<pre><code>query.Where(Restrictions.Gt(Projections.Property(() =&gt; reviewAlias.Rating), 2));
</code></pre>

<p>}
```</p>

<p>Do you see the problem? If we were to rename either <code>FilterQueryByRating</code>&rsquo;s <code>reviewAlias</code> parameter <em>or</em> the <code>reviewAlias</code> that the query is using, our query would not work. In other words, this will not work:</p>

<p>```csharp
// Will explode:
public static void FilterQueryByRating(</p>

<pre><code>IQueryOver&lt;Product, Product&gt; query, 
ProductReview productReviewAlias)
</code></pre>

<p>{</p>

<pre><code>query.Where(Restrictions.Gt(
    Projections.Property(() =&gt; productReviewAlias.Rating), 2));
</code></pre>

<p>}
```</p>

<p>You&rsquo;ll get an error stating &ldquo;could not resolve property: productReviewAlias&hellip;&rdquo;. This is because the alias we&rsquo;re using in the <code>Where</code> clause does not match the one we created when we joined to <code>ProductReview</code>.</p>

<p>This may not seem like a big deal, but you really don&rsquo;t want simply renaming an alias to cause queries to blow up. This is especially true if you&rsquo;re trying to reuse query building methods and you can&rsquo;t guarantee what variable name the user of your method will choose.</p>

<p>To solve this problem, we can create a helper method that will do something similar to what NHibernate is doing under the hood for us&mdash;combine expressions and create a projection from the resulting <code>string</code>:</p>

<p>```csharp
public static PropertyProjection BuildProjection<T>(</p>

<pre><code>Expression&lt;Func&lt;object&gt;&gt; aliasExpression, 
Expression&lt;Func&lt;T, object&gt;&gt; propertyExpression)
</code></pre>

<p>{</p>

<pre><code>string alias = ExpressionProcessor.FindMemberExpression(aliasExpression.Body);
string property = ExpressionProcessor.FindMemberExpression(propertyExpression.Body);

return Projections.Property(string.Format("{0}.{1}", alias, property));
</code></pre>

<p>}
```</p>

<p>(<code>ExpressionProcessor</code> is a class under the <code>NHibernate.Impl</code> namespace)</p>

<p>We&rsquo;ll then update our filtering function to use it:</p>

<p>```csharp
public static void FilterQueryByRating(</p>

<pre><code>IQueryOver&lt;Product, Product&gt; query, 
Expression&lt;Func&lt;object&gt;&gt; productReviewAlias)
</code></pre>

<p>{</p>

<pre><code>PropertyProjection prop = BuildProjection&lt;ProductReview&gt;(
    productReviewAlias, pr =&gt; pr.Rating);

query.Where(Restrictions.Gt(prop, 2));
</code></pre>

<p>}
```</p>

<p>Finally, we need to make a small tweak to our main query:</p>

<p>```csharp
ProductReview reviewAlias = null;</p>

<p>var query = session.QueryOver<Product>()</p>

<pre><code>.JoinAlias(pr =&gt; pr.Reviews, () =&gt; reviewAlias);
</code></pre>

<p>FilterQueryByRating(query, () => reviewAlias);</p>

<p>query</p>

<pre><code>.SelectList(list =&gt; list
    .SelectGroup(pr =&gt; pr.Id)
    .SelectMax(() =&gt; reviewAlias.Rating))
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>This is much more robust: our filtering method doesn&rsquo;t even know what alias the query is using, and if that alias changes or someone decides to use our method in the future, everything will work fine.</p>

<h2>Summary</h2>

<p>I covered a lot in this post, but hopefully it will help you take advantage of QueryOver&rsquo;s most powerful features&mdash;building queries dynamically.</p>

<ul>
<li>Building queries with dynamic SQL can be a pain, but using QueryOver to dynamically build queries can be much easier and more maintainable.</li>
<li>Refactoring conditional restrictions and joins into extension methods can keep queries readable and refactor logic into reusable pieces.</li>
<li>To make those extension methods as robust as possible, we can make the methods generic and therefore more flexible.</li>
<li>Passing around aliases between methods when building QueryOver queries has some pitfalls and needs some special attention.</li>
</ul>

]]></content>
  </entry>
  
</feed>
