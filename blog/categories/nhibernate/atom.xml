<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nhibernate | Andrew Whitaker]]></title>
  <link href="http://blog.andrewawhitaker.com/blog/categories/nhibernate/atom.xml" rel="self"/>
  <link href="http://blog.andrewawhitaker.com/"/>
  <updated>2014-06-20T20:16:29-04:00</updated>
  <id>http://blog.andrewawhitaker.com/</id>
  <author>
    <name><![CDATA[Andrew Whitaker]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[QueryOver Series - Part 4: Transforming]]></title>
    <link href="http://blog.andrewawhitaker.com/blog/2014/06/19/queryover-series-part-4-transforming/"/>
    <updated>2014-06-19T18:51:00-04:00</updated>
    <id>http://blog.andrewawhitaker.com/blog/2014/06/19/queryover-series-part-4-transforming</id>
    <content type="html"><![CDATA[<p>You might have noticed that the last post in the series always projects each result row into an <code>object[]</code>. This might have made you wonder if there&rsquo;s a better way to get results from a QueryOver query. Well there is! It&rsquo;s called transforming.</p>

<p>In the context of an NHibernate query, a <em>transformer</em> is simply a class that transforms each row from a query into an instance of an object. NHibernate comes with several and allows you to easily create a custom transformer if you&rsquo;d like.</p>

<p>Transformers are supplied to the <code>TransformUsing</code> function on an instance of <code>IQueryOver&lt;TRoot, TSubtype&gt;</code>. For example, here&rsquo;s how you would use <code>Transformers.DistinctRootEntity</code> (which I&rsquo;ll go into more detail later about):</p>

<p>```csharp
var results =</p>

<pre><code>session.QueryOver&lt;Product&gt;()
    .TransformUsing(Transformers.DistinctRootEntity)
    .List&lt;Product&gt;();
</code></pre>

<p>```</p>

<h3>Using the built-in transformers</h3>

<p>NHibernate supplies several built-in transformers in the <code>NHibernate.Transform</code> namespace. These may be all you need in your application since they cover most use cases. I&rsquo;ll go over each built-in transformer and how to use it.</p>

<h4><code>DistinctRootEntity</code></h4>

<p>This transformer works the way you&rsquo;d think it would: it transforms the query results into a list of <em>distinct</em> entities of the <em>root</em> type. What&rsquo;s the <em>root</em> type? Well if you read <a href="../../../../2014/03/12/queryover-series-part-1-why-queryover/">part 1</a>, you&rsquo;ll remember that a QueryOver query deals with two types, <code>TRoot</code> and <code>TSubType</code>. the root type is simply <code>TRoot</code>.</p>

<p>For example, here&rsquo;s a query that returns a list of all <code>Product</code>s:</p>

<p>```csharp
// TRoot is Product
IList<Product> results = session.QueryOver<Product>()</p>

<pre><code>.TransformUsing(Transformers.DistinctRootEntity)
.List&lt;Product&gt;();
</code></pre>

<p>```</p>

<p>As you can see, using <code>DistinctRootEntity</code> allows us to get a list of entities easily. This example doesn&rsquo;t address the <em>distinct</em> part of <code>DistinctRootEntity</code>. Here&rsquo;s another, more interesting example:</p>

<p>```csharp
IList<Product> results = session.QueryOver<Product>()</p>

<pre><code>.JoinQueryOver(pr =&gt; pr.TransactionHistory)
    .Where(th =&gt; th.ActualCost &gt; 2.0M)
.TransformUsing(Transformers.DistinctRootEntity)
.List&lt;Product&gt;();
</code></pre>

<p>```</p>

<p>This is more interesting because a <code>Product</code> might have many related rows in <code>TransactionHistory</code>. The join would cause each <code>Product</code> to appear as many times as it has <code>TransactionHistory</code> records, which we probably don&rsquo;t want if we&rsquo;re just trying to find all <code>Product</code>s that were ever priced over $2.00.</p>

<p>Here&rsquo;s the SQL the above query generates:</p>

<p>```sql
SELECT</p>

<pre><code>this_.ProductID as ProductID7_1_,
-- All product columns
transactio1_.TransactionID as Transact1_13_0_,
-- All TransactionHistory columns
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>inner join</p>

<pre><code>Production.TransactionHistory transactio1_
    on this_.ProductID=transactio1_.ProductID
</code></pre>

<p>WHERE</p>

<pre><code>transactio1_.ActualCost &gt; 2;
</code></pre>

<p>```</p>

<p>The result we  get back is a list of distinct <code>Product</code>s.</p>

<p><code>DistinctRootEntity</code> is most useful if you have a simple query in which you need instances of an entity and may or may not want to do filtering on some related entities.</p>

<h4><code>AliasToEntityMap</code></h4>

<p>This transformer allows you to transform each row of the result set into an <code>IDictionary</code> (hash table). Unfortunately it&rsquo;s not a generic <code>IDictionary</code>. The keys are strings containing the aliases you defined in the query, and the values are entities. This is best explained with an example:</p>

<p>``` csharp
TransactionHistory historyAlias = null;
Product productAlias = null;</p>

<p>IList<IDictionary> results = session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.JoinQueryOver(pr =&gt; pr.TransactionHistory, () =&gt; historyAlias)
    .Where(th =&gt; th.ActualCost &gt; 2.0M)
.TransformUsing(Transformers.AliasToEntityMap)
.Take(10)
.List&lt;IDictionary&gt;();
</code></pre>

<p>```</p>

<p>Each item in <code>results</code> is an <code>IDictionary</code>. This <code>IDictionary</code>&rsquo;s keys are the <em>aliases</em> we assigned while building our query. For example, if you wanted to get the first row&rsquo;s <code>TransactionHistory</code> entity, you would write:</p>

<p><code>csharp
TransactionHistory history = (TransactionHistory)results[0]["historyAlias"];
</code></p>

<p>This might seem a bit odd at first, but using <code>AliasToEntityMap</code> can prove useful if you need to retrieve multiple entities in a single query.</p>

<h4><code>PassThrough</code></h4>

<p>This transformer appears to be quite similar to <code>AliasToEntityMap</code> in that it generates a collection of entities for each row in the resultset. I say &ldquo;appears&rdquo; because I haven&rsquo;t had much experience with it and I cannot find much about it online. I&rsquo;ll add to this post if I come across anything interesting.</p>

<p>Anyway for a simple example it seems to place an instance of an entity from the query in a slot in an <code>object</code> array in <em>reverse</em> order from when it was added to the query. For example:</p>

<p>```csharp
IList&lt;object[]> results = session.QueryOver<Product>()</p>

<pre><code>.JoinAlias(pr =&gt; pr.Reviews, () =&gt; reviewAlias)
.JoinQueryOver(pr =&gt; pr.TransactionHistory)
    .Where(th =&gt; th.ActualCost &gt; 2.0M)
.TransformUsing(Transformers.PassThrough)
.Take(10)
.List&lt;object[]&gt;();
</code></pre>

<p>foreach (object[] result in results)
{</p>

<pre><code>ProductReview review = (ProductReview)result[0];
TransactionHistory t = (TransactionHistory)result[1];
Product p = (Product)result[2];
</code></pre>

<p>}
```</p>

<p>As you can see, <code>result[0]</code> is a <code>ProductReview</code>, <code>result[1]</code> is a <code>TransactionHistory</code> and <code>result[2]</code> is the <code>Product</code> itself.</p>

<h4><code>RootEntity</code></h4>

<p><code>RootEntity</code> is similar to <code>DistinctRootEntity</code> in that it projects a list of <code>TRoot</code>. The difference is that the results are <em>not</em> distinct. Therefore if you join on a related table that multiplies the root entity, you&rsquo;ll get back that entity many times for each related row. Here&rsquo;s the example from <code>DistinctRootEntity</code> again, except using <code>RootEntity</code>:</p>

<p>```csharp
IList<Product> results = session.QueryOver<Product>()</p>

<pre><code>.JoinQueryOver(pr =&gt; pr.TransactionHistory)
    .Where(th =&gt; th.ActualCost &gt; 2.0M)
.TransformUsing(Transformers.RootEntity)
.List&lt;Product&gt;();
</code></pre>

<p>```</p>

<p>This will return any <code>Products</code> with a <code>TransactionHistory</code> that has an <code>ActualCost</code> over $2.00, but will not remove duplicate <code>Product</code> records.</p>

<h4><code>ToList</code></h4>

<p>This transformer works very similarly to not specifying a transformer at all and getting back an <code>IList&lt;object[]&gt;</code>. The difference here is that you&rsquo;ll get back an <code>IList&lt;IList&gt;</code> instead.</p>

<p>For example:</p>

<p>```csharp
Product productAlias = null;</p>

<p>IList<IList> results = session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.JoinQueryOver(pr =&gt; pr.TransactionHistory)
    .Where(th =&gt; th.ActualCost &gt; 2.0M)
.TransformUsing(Transformers.ToList)
.SelectList(list =&gt; list
    .Select(() =&gt; productAlias.Id)
    .Select(() =&gt; productAlias.Name)
)
.List&lt;IList&gt;();
</code></pre>

<p>Console.WriteLine(results[0][0]); // product Id
Console.WriteLine(results<a href="http://msdn.microsoft.com/en-us/library/system.reflection.constructorinfo(v=vs.110).aspx">0</a>); // product Name
```</p>

<h4><code>AliasToBean</code></h4>

<p>In my experience, this transformer is by far the most useful. It allows you to transform each row into an instance of a type you specify. You can project columns from different entities into properties on each instance.</p>

<p>Lets use <code>AliasToBean</code> to get a list of <code>HighestProductReviewDTO</code>s. Here&rsquo;s the definition for <code>HighestProductReviewDTO</code>:</p>

<p>```csharp
public class HighestProductReviewDTO
{</p>

<pre><code>public int ProductID { get; set; }

public string ProductName { get; set; }

public int Rating { get; set; }

public string Comments { get; set; }
</code></pre>

<p>}
```</p>

<p>NHibernate requires that the DTO have a parameterless constructor so that it can create an instance of your class for each row it retrieves.</p>

<p>We&rsquo;re going to get a list of <code>Product</code>s that have reviews, followed by some information from that <code>Product</code>&rsquo;s highest review. Here&rsquo;s what our query looks like:</p>

<p>```csharp
IList<HighestProductReviewDTO> highestReviews =</p>

<pre><code>session.QueryOver&lt;Product&gt;(() =&gt; productAlias)
    .JoinQueryOver(pr =&gt; pr.Reviews, () =&gt; productReviewAlias)
        .WithSubquery.Where(pr =&gt; pr.Id == QueryOver.Of&lt;ProductReview&gt;()
            .Where(rev =&gt; rev.Product.Id == productAlias.Id)
            .OrderBy(rev =&gt; rev.Rating).Desc()
            .Select(rev =&gt; rev.Id)
            .Take(1)
            .As&lt;int&gt;())
    .SelectList(list =&gt; list
        .Select(() =&gt; productAlias.Id).WithAlias(() =&gt; result.ProductID)
        .Select(() =&gt; productAlias.Name).WithAlias(() =&gt; result.ProductName)
        .Select(() =&gt; productReviewAlias.Rating).WithAlias(() =&gt; result.Rating)
        .Select(() =&gt; productReviewAlias.Comments).WithAlias(() =&gt; result.Comments)
    )
    .TransformUsing(Transformers.AliasToBean&lt;HighestProductReviewDTO&gt;())
    .List&lt;HighestProductReviewDTO&gt;();
</code></pre>

<p>```</p>

<p>Pay particular attention to the <code>.WithAlias</code> calls at the end of the <code>.Select</code> calls inside of <code>SelectList</code>. These are what tell NHibernate to associate particular column values in each row retrieved with the correct property in our DTO class.</p>

<p>In case you&rsquo;re curious, here&rsquo;s the SQL that NHibernate generated:</p>

<p>```sql
SELECT</p>

<pre><code>this_.ProductID as y0_,
this_.Name as y1_,
productrev1_.Rating as y2_,
productrev1_.Comments as y3_
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>inner join</p>

<pre><code>Production.ProductReview productrev1_
    on this_.ProductID=productrev1_.ProductID
</code></pre>

<p>WHERE</p>

<pre><code>productrev1_.ProductReviewID = (
    SELECT
        TOP (1)  this_0_.ProductReviewID as y0_
    FROM
        Production.ProductReview this_0_
    WHERE
        this_0_.ProductID = this_.ProductID
    ORDER BY
        this_0_.Rating desc
</code></pre>

<p>```</p>

<p><code>AliasToBean</code> is extremely useful. It allows us to specify exactly what columns we need and transform the resulting rows into instances of simple types. However it does have some limitations:</p>

<ul>
<li>The class you&rsquo;re projecting to must have a parameterless constructor</li>
<li>You cannot populate collections (e.g., if you had a class with <code>ProductID</code> and a collection of <code>ProductReviews</code> you could not do that in one step using <code>AliasToBean</code>)</li>
<li>You cannot populate full entities (e.g., <code>.Select(() =&gt; productReview.Product).WithAlias(() =&gt; result.Product)</code>)</li>
</ul>


<p>While the second limitation is unfortunate, you <em>can</em> specify a collection type in your result class and write a separate query to populate it. You can possibly even do this in one database round trip using the <code>.Future</code> method, which I&rsquo;ll talk about in a later post.</p>

<h4><code>AliasToBeanConstructor</code></h4>

<p><code>AliasToBeanConstructor</code> is similar to <code>AliasToBean</code>, except that it uses a result type&rsquo;s constructor to create new objects from result rows. Here&rsquo;s our example from above slightly modified to use <code>AliasToBeanConstructor</code> instead.</p>

<p>Here&rsquo;s our modified result class:</p>

<p>```csharp
public class HighestProductReviewDTO
{</p>

<pre><code>public HighestProductReviewDTO(
    int productId, string productName, int rating, string comments)
{
    this.ProductID = productId;
    this.ProductName = productName;
    this.Rating = rating;
    this.Comments = comments;
}

public int ProductID { get; private set; }

public string ProductName { get; private set; }

public int Rating { get; private set; }

public string Comments { get; private set; }
</code></pre>

<p>}
```</p>

<p>And here&rsquo;s our new QueryOver query:</p>

<p>```csharp
IList<HighestProductReviewDTO> highestReviews =</p>

<pre><code>session.QueryOver&lt;Product&gt;(() =&gt; productAlias)
    .JoinQueryOver(pr =&gt; pr.Reviews, () =&gt; productReviewAlias)
        .WithSubquery.Where(pr =&gt; pr.Id == QueryOver.Of&lt;ProductReview&gt;()
            .Where(rev =&gt; rev.Product.Id == productAlias.Id)
            .OrderBy(rev =&gt; rev.Rating).Desc()
            .Select(rev =&gt; rev.Id)
            .Take(1)
            .As&lt;int&gt;())
    .SelectList(list =&gt; list
        .Select(() =&gt; productAlias.Id)
        .Select(() =&gt; productAlias.Name)
        .Select(() =&gt; productReviewAlias.Rating)
        .Select(() =&gt; productReviewAlias.Comments)
    )
    .TransformUsing(Transformers.AliasToBeanConstructor(
        typeof(HighestProductReviewDTO).GetConstructors().First()))
    .List&lt;HighestProductReviewDTO&gt;();
</code></pre>

<p>```</p>

<p>We&rsquo;re passing <a href="http://msdn.microsoft.com/en-us/library/system.reflection.constructorinfo(v=vs.110).aspx"><code>ConstructorInfo</code></a> to <code>AliasToBeanConstructor</code> which we get using <code>GetConstructors</code>. NHibernate calls our constructor with the column values we&rsquo;re retrieving with our <code>SelectList</code>. Note that <em>all</em> items in the <code>SelectList</code> are passed to the constructor in the order you add them.</p>

<h3>Creating your own transformer</h3>

<p>The built in transformers are great, but if you need your own result transformer, that&rsquo;s possible too.</p>

<p>For example, let&rsquo;s say we want to call a callback function every time a row is transformed. We could also iterate over our results after retrieving them, but this gives us a way to apply any modifications we might want while we&rsquo;re transforming the row. Here&rsquo;s our new transformer class:</p>

<p>```csharp
/// <summary>
/// A result transformer that calls a callback after successfully transforming a result row
/// into an instance of T
/// </summary>
/// <typeparam name="T">The result type</typeparam>
public class AliasToBeanWithCallbackTransformer<T> : IResultTransformer
{</p>

<pre><code>private readonly AliasToBeanResultTransformer aliasToBeanTransformer;
private readonly Action&lt;T&gt; callback;

public AliasToBeanWithCallbackTransformer(Action&lt;T&gt; callback)
{
    this.aliasToBeanTransformer = new AliasToBeanResultTransformer(typeof(T));
    this.callback = callback;
}

public IList TransformList(IList collection)
{
    return this.aliasToBeanTransformer.TransformList(collection);
}

public object TransformTuple(object[] tuple, string[] aliases)
{
    object result = this.aliasToBeanTransformer.TransformTuple(tuple, aliases);

    // Call the callback before returning the result.
    callback((T)result);

    return result;
}
</code></pre>

<p>}
```</p>

<p>In this example, all I&rsquo;ve done is wrap <code>AliasToBeanResultTransformer</code> in a class that calls the callback the user specifies after calling <code>AliasToBeanResultTransformer</code>&rsquo;s <code>TransformTuple</code> method. I&rsquo;ll use this transformer in an example that retrieves product review information but with an added property, <code>DateRetrieved</code>:</p>

<p>```csharp
public class ProductReviewDTO
{</p>

<pre><code>public int ProductReviewID { get; set; }

public int Rating { get; set; }

public string Comments { get; set; }

public DateTime DateRetrieved { get; set; }
</code></pre>

<p>}
```</p>

<p>We can use the transformer to assign <code>DateRetrieved</code> after creating a new <code>ProductReviewDTO</code>:</p>

<p>```csharp
DateTime dateRetrieved = DateTime.Now;</p>

<p>IList<ProductReviewDTO> highestReviews =</p>

<pre><code>session.QueryOver&lt;ProductReview&gt;()
    .SelectList(list =&gt; list
        .Select(pr =&gt; pr.Comments).WithAlias(() =&gt; result.Comments)
        .Select(pr =&gt; pr.Id).WithAlias(() =&gt; result.ProductReviewID)
        .Select(pr =&gt; pr.Rating).WithAlias(() =&gt; result.Rating)
    )
    // Assign "DateRetrieved correctly:
    .TransformUsing(new AliasToBeanWithCallbackTransformer&lt;ProductReviewDTO&gt;(
        hp =&gt; hp.DateRetrieved = dateRetrieved))
    .Take(10)
    .List&lt;ProductReviewDTO&gt;();
</code></pre>

<p>```</p>

<p>This is a simple example, but it should demonstrate how easy it is to extend the built in transformers. It would be nice if we could subclass the built in transformers, but unfortunately the methods we would need to override are not marked <code>virtual</code>.</p>

<p>A good place to look for how to write a transformer is the <a href="https://github.com/nhibernate/nhibernate-core/tree/master/src/NHibernate/Transform">NHibernate source code itself</a>.</p>

<h3>Summary</h3>

<p>I covered a lot in this post, but I was aiming to be comprehensive with each transformer type. This should enable you to effectively use the built in transformers and create your own if you need to.</p>

<ul>
<li>There are several built in result transformers in the <code>NHibernate.Transform</code> namespace.</li>
<li><code>DistinctRootEntity</code> and <code>RootEntity</code> retrieve a list of the &ldquo;root&rdquo; of the QueryOver query</li>
<li><code>AliasToEntityMap</code> and <code>PassThrough</code> retrieve the entities present in the QueryOver query in an <code>IDictionary</code> and <code>object[]</code>, respectively.</li>
<li><code>AliasToBean</code> and <code>AliasToBeanConstructor</code> are powerful transformers that allow you to create a list of instances of a type you specify.</li>
<li>You can create your own result transformer pretty easily to suit your needs.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QueryOver Series - Part 3: Selecting]]></title>
    <link href="http://blog.andrewawhitaker.com/blog/2014/03/22/queryover-series-part-3-selecting-and-transforming/"/>
    <updated>2014-03-22T11:01:46-04:00</updated>
    <id>http://blog.andrewawhitaker.com/blog/2014/03/22/queryover-series-part-3-selecting-and-transforming</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;ll go over building the <code>SELECT</code> statement with NHibernate QueryOver. I&rsquo;ll also cover the different ways you can actually get a result back from your query.</p>

<h3>Selecting a single property</h3>

<p>In the simplest case, you&rsquo;ll want to select a single column from a single row. For example, if you wanted to retrieve a single <code>Product</code>&rsquo;s <code>Name</code>:</p>

<p>``` csharp
string name = session.QueryOver<Product>()</p>

<pre><code>.Where(p =&gt; p.Id == 1)
.Select(p =&gt; p.Name)
.SingleOrDefault&lt;string&gt;();
</code></pre>

<p>```</p>

<p>Which yields the following SQL:</p>

<p>``` sql
SELECT</p>

<pre><code>this_.Name as y0_
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>WHERE</p>

<pre><code>this_.ProductID = 1;
</code></pre>

<p>```</p>

<p>Note that if your query actually returns more than one result, NHibernate will throw an exception, letting you know that the query did not return a unique result.</p>

<p>Similarly, if you want to select a list of single properties, say the <code>Name</code> of every <code>Product</code>:</p>

<p>``` csharp
IList<string> names = session.QueryOver<Product>()</p>

<pre><code>.Select(p =&gt; p.Name)
.List&lt;string&gt;();
</code></pre>

<p>```</p>

<p>Generates:</p>

<p>``` sql
SELECT</p>

<pre><code>this_.Name as y0_
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>```</p>

<h3>Selecting multiple properties</h3>

<p>Most of the time you won&rsquo;t want to select just one column, you&rsquo;ll want to build a whole result set. You have a few options in this area:</p>

<h4>Using <code>SelectList</code></h4>

<p><code>SelectList</code> is one way to specify a list of properties you&rsquo;d like to select. Here&rsquo;s a simple example:</p>

<p>``` csharp
IList&lt;object[]> productInformation = session.QueryOver<Product>()</p>

<pre><code>.SelectList(list =&gt; list
    .Select(p =&gt; p.Id)
    .Select(p =&gt; p.Name)
    .Select(p =&gt; p.StandardCost)
)
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>This generates the SQL you&rsquo;d expect:</p>

<p>``` sql
SELECT</p>

<pre><code>this_.ProductID as y0_,
this_.Name as y1_,
this_.StandardCost as y2_
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>```</p>

<p>Those are the basics of using <code>SelectList</code>. There are some cool things you can do with <code>SelectList</code> to build <code>SELECT</code> clauses dynamically.</p>

<p><code>SelectList</code> accepts a <code>QueryOverProjectionBuilder&lt;TRoot&gt;</code>. We can take advantage of QueryOver&rsquo;s dynamic nature to dynamically build a select list.</p>

<p>One way to do this is to create a method that accepts a <code>QueryOverProjectionBuilder&lt;TRoot&gt;</code> and has the same return type. To expand on the <code>Product</code> example above:</p>

<p>``` csharp
static QueryOverProjectionBuilder<Product> BuildSelectList(</p>

<pre><code>QueryOverProjectionBuilder&lt;Product&gt; list)
</code></pre>

<p>{</p>

<pre><code>bool getName = /* some condition */;

if (getName)
{
    list.Select(p =&gt; p.Name);
}

list
    .Select(p =&gt; p.Id)
    .Select(p =&gt; p.StandardCost);

return list;
</code></pre>

<p>}
```</p>

<p>We can then call the method directly from <code>SelectList</code>:</p>

<p>``` csharp
IList&lt;object[]> names = session.QueryOver<Product>()</p>

<pre><code>.SelectList(BuildSelectList)
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<h4>Using <code>Projections.ProjectionList()</code></h4>

<p>Another way to build a <code>SELECT</code> clause is using <code>Projections.ProjectionList()</code>. You can pass a <code>ProjectionList</code> to the <code>.Select</code> method:</p>

<p>``` csharp
Product productAlias = null;</p>

<p>session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.Select(Projections.ProjectionList()
    .Add(Projections.Property(() =&gt; productAlias.Id))
    .Add(Projections.Property(() =&gt; productAlias.Name))
)
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>This generates the following SQL:</p>

<p>``` sql
SELECT</p>

<pre><code>this_.ProductID as y0_,
this_.Name as y1_
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>```</p>

<p>It&rsquo;s also easy to generate dynamic <code>SELECT</code> clauses with <code>ProjectionList</code>:</p>

<p>``` csharp
Product productAlias = null;</p>

<p>ProjectionList projectionList = Projections.ProjectionList()</p>

<pre><code>.Add(Projections.Property(() =&gt; productAlias.Id))
.Add(Projections.Property(() =&gt; productAlias.StandardCost));
</code></pre>

<p>bool getName = true;</p>

<p>if (getName)
{</p>

<pre><code>projectionList.Add(Projections.Property(() =&gt; productAlias.Name));
</code></pre>

<p>}</p>

<p>session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.Select(projectionList)
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>I think if you&rsquo;re dynamically building the <code>SELECT</code> clause, <code>Projections.ProjectionList</code> is actually cleaner, due to the way you can easily build it outside of the query itself.</p>

<h3>Aggregates</h3>

<p>So far I&rsquo;ve looked at building simple <code>SELECT</code>s. Now I&rsquo;ll look at using aggregate functions.</p>

<p>In the simplest cases, using <code>SelectList</code> along with <code>SelectGroup</code> and the aggregate function you want will get the job done.</p>

<p>For example:</p>

<p>``` csharp
session.QueryOver<Product>()</p>

<pre><code>.JoinQueryOver(pr =&gt; pr.TransactionHistory, () =&gt; transactionHistoryAlias)
.SelectList(list =&gt; list
    .SelectGroup(pr =&gt; pr.Id)
    .SelectCount(() =&gt; transactionHistoryAlias.Id)
)
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>Will generate:</p>

<p>``` sql
SELECT</p>

<pre><code>this_.ProductID as y0_,
count(transactio1_.TransactionID) as y1_
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>inner join</p>

<pre><code>Production.TransactionHistory transactio1_
    on this_.ProductID=transactio1_.ProductID
</code></pre>

<p>GROUP BY</p>

<pre><code>this_.ProductID
</code></pre>

<p>```</p>

<p>You can call <code>SelectGroup</code> multiple times to add more columns to group on. You&rsquo;ll notice that <code>.SelectGroup</code> adds a column to the <code>GROUP BY</code> clause as well as the <code>SELECT</code> clause.</p>

<p>You can also add a <code>HAVING</code> clause, although it is <em>not</em> intuitive at all:</p>

<p>``` csharp
var results = session.QueryOver<Product>()</p>

<pre><code>.JoinQueryOver(pr =&gt; pr.TransactionHistory, () =&gt; transactionHistoryAlias)
.SelectList(list =&gt; list
    .SelectGroup(pr =&gt; pr.Id)
    .SelectGroup(pr =&gt; pr.Name)
    .SelectCount(() =&gt; transactionHistoryAlias.Id)
)
/* Generates a HAVING clause: */
.Where(Restrictions.Gt(
    Projections.Count(
        Projections.Property(() =&gt; transactionHistoryAlias.Id)), 5))
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>This generates the following SQL:</p>

<p>``` sql
SELECT</p>

<pre><code>this_.ProductID as y0_,
this_.Name as y1_,
count(transactio1_.TransactionID) as y2_
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>inner join</p>

<pre><code>Production.TransactionHistory transactio1_
    on this_.ProductID=transactio1_.ProductID
</code></pre>

<p>GROUP BY</p>

<pre><code>this_.ProductID,
this_.Name
</code></pre>

<p>HAVING</p>

<pre><code>count(transactio1_.TransactionID) &gt; 5;
</code></pre>

<p>```</p>

<h3>Subqueries</h3>

<p>There are several ways to create subqueries. You can create a correlated subquery by creating an alias in the outer query and referencing it in the other query. Here&rsquo;s an example using <code>SelectList</code> and <code>SelectSubQuery</code>:</p>

<p>``` csharp
var results = session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.SelectList(list =&gt; list
    .Select(pr =&gt; pr.Id)
    .SelectSubQuery(
        QueryOver.Of&lt;TransactionHistory&gt;()
            // Creates a correlated subquery
            .Where(tx =&gt; tx.Product.Id == productAlias.Id)
            .OrderBy(tx =&gt; tx.TransactionDate).Asc
            .Select(tx =&gt; tx.TransactionDate)
            .Take(1)
        )
)
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>Which generates:</p>

<p>``` sql
SELECT
   this<em>.ProductID as y0</em>,
   (SELECT</p>

<pre><code>   TOP (1)  this_0_.TransactionDate as y0_
</code></pre>

<p>   FROM</p>

<pre><code>   Production.TransactionHistory this_0_
</code></pre>

<p>   WHERE</p>

<pre><code>   this_0_.ProductID = this_.ProductID
</code></pre>

<p>   ORDER BY</p>

<pre><code>   this_0_.TransactionDate asc) as y1_
</code></pre>

<p>FROM
   Production.Product this_;
```</p>

<p>In general, if you can&rsquo;t find a method on <code>QueryOverProjectionBuilder&lt;TRoot&gt;</code> using <code>.SelectList</code>, you can drop back into criteria methods on the <code>Projections</code> class. For example, say you want to use a case statement in your <code>SELECT</code> clause. You can use <code>Projections.Conditional</code> for that:</p>

<p>``` csharp
var results = session.QueryOver<Product>(() => productAlias)</p>

<pre><code>.JoinQueryOver(pr =&gt; pr.TransactionHistory, () =&gt; transactionHistoryAlias)
.SelectList(list =&gt; list
    .Select(pr =&gt; pr.Id)
    .Select(Projections.Conditional(
        Restrictions.Gt(
            Projections.Property(() =&gt; transactionHistoryAlias.Quantity), 5),
        Projections.Constant(true),
        Projections.Constant(false)
)))
.List&lt;object[]&gt;();
</code></pre>

<p>```</p>

<p>Which generates:</p>

<p>``` sql
SELECT</p>

<pre><code>this_.ProductID as y0_,
(case
    when transactio1_.Quantity &gt; 5 then 'True'
    else 'False'
end) as y1_
</code></pre>

<p>FROM</p>

<pre><code>Production.Product this_
</code></pre>

<p>inner join</p>

<pre><code>Production.TransactionHistory transactio1_
    on this_.ProductID=transactio1_.ProductID;
</code></pre>

<p>```</p>

<h3>Summary</h3>

<p>This post covered a lot, but that&rsquo;s because there are many ways to build a <code>SELECT</code> clause with QueryOver. In summary:</p>

<ul>
<li><code>Select</code> can be used to build a <code>SELECT</code> clause with single columns</li>
<li><code>SelectList</code> and <code>Projections.ProjectionList</code> can be used to create more complex <code>SELECT</code> clauses.</li>
<li>When aggregating values, use <code>SelectGroup</code> (or <code>Projections.GroupProperty</code>).</li>
<li>For more complex scenarios, you can drop back in to Criteria methods on the <code>Projections</code> class. These support lambda expressions and can be used with QueryOver.</li>
</ul>

]]></content>
  </entry>
  
</feed>
